### Классификация ошибок компиляции (CE)
***`Ошибка компиляции (compile-time error)` - ситуация, когда не удалось создать исполняемый файл из данной программы***

В любом формальном ЯП есть лексика, синтаксис и семантика. Соответственно, ошибки компиляции бывают:
- лексические
- синтаксические 
- семантические
#### Лексические ошибки
Задача лексического парсера (работает на одной из начальных стадий компиляции) - разбить код на токены, то есть на слова, значащие куски и т.п.

Дальше задача компилятора понять что значит по смыслу каждый из токенов и к какой категории он относится

Потом происходит семантическое связывание - компилятор должен понять можно ли вообще сделать определенную инструкцию или нет, почему что-то сделать нельзя и т.д.

```cpp
int main() {
	\\; 
}
```
Выше приведена лексическая ошибка

***Начиная с C++11 можно доопределять свои литеральные суффиксы***

#### Синтаксические ошибки
```cpp
std::cout << x +;
```
Синтаксически предложение некорректно. Синтаксический парсер сломался - не получается выражение распарсить

***Токен - это отдельное слово с точки зрения компилятора, осмысленная последовательность символов***

#### Семантические ошибки: неопределенная операция или неоднозначная операция
Наиболее часто причина CE - это то, что мы пытаемся вызвать операцию над операндами, которые не поддерживают такую операцию

```cpp
"abc" + 5.0f;

++x++;
```

Также семантическими ошибками является обращение к необъявленной переменной/функции или обращение к функции/переменной такое, что оно порождает неоднозначность

Еще бывают ошибки доступа

### Понятие runtime error (RE)
Программа скомпилировалась, из нее получилось сделать исполняемый файл, который запускается, но он может упасть во время выполнения - это будет `runtime error`

#### Segmentation fault (segfault)
Топ 1 ошибка, которая бывает в рантайме

Возникает, когда пытаемся обратиться к памяти, к которой не имеем права обращаться, или когда нарушаем режим доступа к памяти
```cpp
std::vector<int> v(10);
v[50'000] = 1; 
```

*Если я обращаюсь к ячейке памяти, которая не сильно дальше, чем размер вектора, то я еще не падаю (например, `v[5'000] = 1;` - не падаем в рантайме), а получаю случайные числа до какого-то момента*

Память тоже бывает для чтения, для выполнения и для записи

#### Floating point exception (FPE)
```cpp
int main() {
	int y;
	std::cin >> y;

	std::cout << 5 / y;
}
```
Возникает прямо в процессоре - процессор видит, что надо поделить два целых числа, а второе из них, тогда генерирует вот это и это через систему обратной связи прилетает нам

Если поделить на ноль в дробных числах, то все будет нормально
```cpp
float y;
std::cin >> y; // input 0
std::cout << 5 / y; // output inf
```
Дело в том, что у чисел с плавающей точкой есть специальное значение бесконечность

#### Aborted
Вторая по частоте ошибка, вызов сишной функции `abort()` - наша программа аварийно завершается ОС. Эта функция вызывается некоторыми другими функциями стандартной библиотеки, когда они понимают, что что-то пошло совсем не так, например обратимся к вектору по индексу, превосходящему его размер, через метод `at`

`double free or corruption` это тоже вызов функции `abort`. Плюсовый код вызывает сишный код, а сишный код вызывает функцию `abort()`
```cpp
v[-1] = 1'000; // double free or corruption
```

Из всего этого `CE` - меньшее зло, потому что, когда у нас программа уже скомпилирована, гораздо меньше шансов, что она упадет по причине каких-то неопределенных операций/непонятного вызова функций и т.д. Лучше заранее проверить, что во всем коде все операции, все вызовы функций корректны

### Понятие Undifined behaviour (UB)
Ситуация, когда наша программа некорректна, но это не отлавливается на стадии компиляции и на стадии выполнения тоже может не отловиться - можем упасть, а можем и нет, а может что-то пойти по-другому и мы это никак не предугадаем

Компилятор перестает давать нам какие-либо гарантии, что он сделает с нашим кодом
```cpp
std::vector<int> v(10);
v[10] = 1; // UB
```
Неопределенное в том смысле, что мы можем упасть, а можем и не упасть, компилятор ничего нам не гарантирует. Что произойдет при выполнении такого кода - неизвестно

```cpp
int x;
std::cout << x; // UB

x++ + ++x; // UB
```
Неупорядоченные относительно друг друга выражения, относительно одной и той же переменной - это UB

Иногда UB приводит к RE, иногда приводит к тому, что наша программа выводит рандомные числа

Переполнение `int` - UB, а вот переполнение `unsigned` не является UB

```cpp
int main() {
	for (int i = 0; i < 300; ++i) {
		std::cout << i << ' ' << i * 12345678 << std::endl;
	}
}
```
Если скомпилировать это с оптимизациями `-O2`, то цикл свалится в бесконечный. Происходит это потому, что компилятор решает, что он имеет право не проверять `i < 300`, он решает, что это условие всегда верно, потому что из наличия в коде выражения `i * 12345678` следует, что `i < 174`, а значит нет смысла сравнивать с 300 - экономим на операции сравнения

*Компилятор работает в предположении, что UB отсутствуют в программе*

*UB самое ужасное, что есть в C++*

Если в программе есть UB, то оно может случайно выстрелить в любой момент и мы заранее никак не подстрахуемся от этого

### Понятия Unspecified behaviour, implementation-defined behaviour и IFNDR
Есть несколько видов ошибочных программ

![](../images/Pasted%20image%2020240831194819.png)

***`Unspecified behaviour` - когда ограничения, что может произойти есть, но они не говорят конкретно, что будет (порядок вычислений)***

***`Implementation-defined behaviour` - когда в зависимости от того, где, на какой машине, под каким компилятором мы запускаемся у нас могут быть разные выводы (размер какого-то типа)***

Почему существует UB? Потому что именно оно позволяет нам делать агрессивные оптимизации. Компилятор может оптимизировать наш код, в предположении, что в нем нет UB. За счет этого сильно выигрывает в скорости выполнения корректных программ, а некорректные начинают делать что-то непредсказуемое

### The as-if rule
По сути это и есть зеленый свет компилятору на то, что он может делать все что угодно с нашим кодом, лишь бы наблюдаемое поведение было таким, каким ожидается

Компилятор C++ имеет право как угодно переставлять инструкции, действия нашей программы только лишь при условии, чтобы наблюдаемое поведение корректной программы осталось таким же:
- все чтения переменных дают нам то, что они должны нам дать, как если бы оно выполнялось последовательно
- в конце программы все данные записаны в файлы, туда куда они должны быть записаны
- все что было выведено в консоль - выведено
- чтобы все в таком порядке и делалось

В остальном он имеет право как угодно переупорядочивать действия нашей программы, в предположении, что у нас нет UB

### Предупреждения компилятора (Warnings)
`Warning` это не ошибка компиляции и он не мешает созданию исполняемого файла. Это некоторое наблюдение компилятора, замечание, относительно того, что он видит в нашем коде и подозревает, что это может быть проблемой. Это не ошибки с точки зрения языка C++

После каждого `Warning` он говорит, чем был вызван вид этого предупреждения - какого типа замечание

### Флаги компиляции -Wall, -Wextra, -Werror и -Wpedantic
`-Wall` - предупреждай обо всем. На сайте gcc можно посмотреть какие именно `Warnings` включаются при флаге `-Wall`

`-Wextra` - показывает еще некоторые, более хитрые предупреждения

`-Wpedantic` - заставляет компилятор быть педантичным. Начнет предупреждать о нарушениях стандарта, которые компилятор по умолчанию допускает, но они не стандартизованы

`-Werror` - все предупреждения превращаются в ошибки компиляции. Страхует нас от тех вещей, которые иначе были бы UB

Можно какие-нибудь отдельные ошибки убирать. Для этого используем `-Wno-error=<type>`

Аналогично можно убрать предупреждение в целом - `-Wno-<type>`

Можно прямо в коде программы с помощью команды `#pragma` на кусок кода наложить дополнительный параметр компиляции
```cpp
#pragma GCC diagnostic push("<params>")

// some code

#pragma GCC diagnostic pop
```
