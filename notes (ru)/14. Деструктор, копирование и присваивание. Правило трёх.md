## 3.3.2 Destructor (dtor)

Операция обратная ctor - это функция, которая вызывается перед тем как объект будет уничтожен, в частности, перед тем как закончится время жизни объекта, выход из области видимости. **Декструтры вызываются в порядке обратному конструированию**: сначал вызывается dtor для объекта, для которого ctor был вызыван последним.

Для большинства типов, у которых тривиальный конструктор, деструктор тоже тривиальный. Но если конструктуро делал какие-то нетривиальные действия, например, захват ресурсов - то деструктор должен обязательно сделать противоположное действие (вызвобождение ресурсов).

Тривиальный деструктуры обычно даже не упоминают, он сгенерируется автоматически без всяких `=default`, как это делается для конструкторов. Так что ничего писать не надо обычно. Хотя можно написать `=default` тоже. Можно так написать, но обычно так не пишут, не особо принято; особенно, если у вас примитивный класс.

Вот так точно не надо делать:

```cpp
  class Complex {
    public:
      double re = 0.0;
      double im = 0.0;
      ~Complex () {   // dtor
        re = 0.0;
        im = 0.0;
      }
    }
```

С символом тильда `~` как раз деструктор получается. Но НЕ НАДО (так делают некоторые даже на физтехе...) тупо занулять значения полей класса. Это не то, что должен делать деструктор. Не нужно присваивать ноль полям класса (как и локальным переменным) - они просто снимаются со стека, когда выходим из области видимости и все.

Когда же нужно? Когда был нетривиальный ctor, например тут:

```cpp
  class String {
    public:
      String (size_t n, char symb) : arr(new char[n + 1]), sz(n), cap(n + 1) {
        /* ... */
      }      
    private:
      /* ... */
  };
```

НЕтривиальный ctor -> нужен НЕтривиальный dtor. В чем его НЕтривиальность будет? В том, что мы вызвали new, а теперь значит должны вызывать delete.

```cpp
  ~String () {
    // вот тут список действий, которы необходимо выполнить
    // перед уничтожением объекта 
    delete[] arr;
  }
```

Деструктор для каждого объекта должен быть вызван лишь один раз. Если для какого-то объекта деструктор вызван более одного раза - это `UB`. Как? Можно явно вызывать деструктор (`s.~String`), а потом он вызовется сам еще перед выходом из `scope`. На самом деле, бывает нужно вызывать `dtor` явно (потом посмотрим). Обратите внимание, что имя `s` даже после явного вызова `dtor` все равно будет занято, пока мы не выйдем из локального `scope`.

Поскольку в `Cpp` нет сборщика мусора - можно однозначно сказать в какой момент будут вызыван деструктор для каждого из объектов (в том момент, когда заканчивается `scope`). А если был сборщик мусора (как, например, в java) - то не было бы такой детерминированности: в java деструктор вызывается тогда, когда программа посчитает, что на объект больше нет ссылок; а посчитает он это тогда, когда это заметит; а когда заметит -- ну... тогда, когда заметит.

Деструктор по-умолчанию всегда сам генерируется, компилятор в любом случае сгенерирует дефолтный деструктор, но иногда он будет делать несовсем то, что нужно вам. Дефолтный деструктор просто вызывает dtor для всех полей класса в порядке обратном объявлению.

Например, если тут не написали бы dtor (или написали бы `~String () = default;`

```cpp
  class String {
    public:
      String (size_t n, char symb) : arr(new char[n + 1]), sz(n), cap(n + 1) {
        /* ... */
      }
  }
```

то тогда произошла бы утечка памяти (потому что delete не сделал высвобождение памяти, а просто вызывал для всех полей dtor).

**Q1.** Допустим у меня есть dtor, а полями являются какие-то объекты, у которых тоже свои dtor есть и они все нетривиальные - в каком порядке что произойдет? 1) сначала код моего деструктора, а потом деструкторы полей или 2) сначала деструкторы полей, а после код моего деструктора?

**Ответ - 1**. Пока я нахожусь в теле моего деструктора поля еще живы, к ним еще можно обращаться. Они еще не уничтожены. После этого деструктуры остальных полей будут выполнены автоматически после выхода из моего деструктора в обратном порядке объявления.

## 3.3.3 Сopy constructor (copy)

Данный конструктор позволяет сделать объект вашего класса из другого объекта ТАКОГО же класса. Обычно `copy` имеет такую сигнатуру:

```cpp
  String (const String& other) {} // copy
```

Почему ссылка и почему `const`. Понятно, что принимать объект по значению в `copy` - это полный кринж, потому что копирование объекта и описывается `copy`: чтобы передать объект по значению, его нужно было именно скопировать, а копирование мы и хотим определить. Можно было бы принимать в `copy` без слова `const` - так можно (это тоже конструктор копирования - `String(String& other) {}`), но такое редко бывает нужно: обычно копирование константных объектов не отличается, и чтобы `copy` работал и для константатных и для НЕконстантных объектов - сразу пишем `const`. Хотя бывает, что для константатных и НЕконстантных объектов нужно по-разному объявлять конструктор копирования (но это очень редко).

Компилятор тоже умеет генерировать `copy` по-умолчанию, даже если у вас есть НЕтривиальные `ctor`. Как он выглядит? Просто скопировать значения всех полей по-элементно. Для тупых классов, вроде `Complex` выше - `copy` дефолтный подходит. Но для `string`, где у нас выделяется динамическая память и заполняется чем-то - тут уже не подходит дефолтный `copy`.

### Сopy-on-write (COW)

Смысл: конструктор копирования оставляется тривиальным, а реальное копирование делается тогда, когда-то кто-то пытается изменить копию. Это такое линивое копирование. Когда вас попросили скопировать - вы еще ничего не скопировали, вы переприсвоили поля и запомнили, что вы не единственный, кто на эту строку указывает. А КОГДА вы попытались туда что-то записать, вот тогда вы начинаете делать копию: вы поняли, что вас хотят изменить, а вы не единственный - значит вам нужно копироваться в этот момент. 

----

Но давайте полноценный напишем для `String`

```cpp
  class String {
    public:
      String (size_t n, char symb) : arr(new char[n + 1]), sz(n), cap(n + 1) {
        /* ... */
      }
      String (const& String other) : arr(new char[other.cap]), sz(other.sz), cap(other.cap) {
        memcpy(arr, other.arr, sz + 1) //
                                       // работает так же, как std::copy
                                       // обе написаны так, что если примитивные типы, то
                                       // он копирует машинными словами (по 8 байт, а не 1 байт)
                                       // 
                                       // если НЕпиритивный тип, например vector<std::string>, то
                                       // memcpy - нельзя вызывать, нужно std::copy
                                       //
                                       // std::copy копирует честно - ВЫЗЫВАЕТ КОНСТРУКТОРЫ COPY
                                       // а memcpy просто по байтам копирует память
                                       // - для примитивный типов ОК, а для НЕпритивных - НЕок
                                       //
                                       // есть еще strcpy - она по 1 байту работает -> не эффект.
                                       //
                                       // есть еще memmove - он делает тоже копирование,
                                       // но он дает гарантию, что если диапозоны пересекались,
                                       // то все будет корректно
                                       // 
      }
  }
```

