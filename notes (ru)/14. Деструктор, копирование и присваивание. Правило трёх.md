## 3.3.2 Destructor (dtor)

Операция обратная ctor - это функция, которая вызывается перед тем как объект будет уничтожен, в частности, перед тем как закончится время жизни объекта, выход из области видимости. **Декструтры вызываются в порядке обратному конструированию**: сначал вызывается dtor для объекта, для которого ctor был вызыван последним.

Для большинства типов, у которых тривиальный конструктор, деструктор тоже тривиальный. Но если конструктуро делал какие-то нетривиальные действия, например, захват ресурсов - то деструктор должен обязательно сделать противоположное действие (вызвобождение ресурсов).

Тривиальный деструктуры обычно даже не упоминают, он сгенерируется автоматически без всяких `=default`, как это делается для конструкторов. Так что ничего писать не надо обычно. Хотя можно написать `=default` тоже. Можно так написать, но обычно так не пишут, не особо принято; особенно, если у вас примитивный класс.

Вот так точно не надо делать:

```cpp
  class Complex {
    public:
      double re = 0.0;
      double im = 0.0;
      ~Complex () {   // dtor
        re = 0.0;
        im = 0.0;
      }
    }
```

С символом тильда `~` как раз деструктор получается. Но НЕ НАДО (так делают некоторые даже на физтехе...) тупо занулять значения полей класса. Это не то, что должен делать деструктор. Не нужно присваивать ноль полям класса (как и локальным переменным) - они просто снимаются со стека, когда выходим из области видимости и все.

Когда же нужно? Когда был нетривиальный ctor, например тут:

```cpp
  class String {
    public:
      String (size_t n, char symb) : arr(new char[n + 1]), sz(n), cap(n + 1) {
                /* ... */
      }      
    private:
                /* ... */
  };
```

НЕтривиальный ctor -> нужен НЕтривиальный dtor. В чем его НЕтривиальность будет? В том, что мы вызвали new, а теперь значит должны вызывать delete.

```cpp
  ~String () {
    // вот тут список действий, которы необходимо выполнить
    // перед уничтожением объекта 
    delete[] arr;
  }
```

Деструктор для каждого объекта должен быть вызван лишь один раз. Если для какого-то объекта деструктор вызван более одного раза - это `UB`. Как? Можно явно вызывать деструктор (`s.~String`), а потом он вызовется сам еще перед выходом из `scope`. На самом деле, бывает нужно вызывать `dtor` явно (потом посмотрим). Обратите внимание, что имя `s` даже после явного вызова `dtor` все равно будет занято, пока мы не выйдем из локального `scope`.

Поскольку в `Cpp` нет сборщика мусора - можно однозначно сказать в какой момент будут вызыван деструктор для каждого из объектов (в том момент, когда заканчивается `scope`). А если был сборщик мусора (как, например, в java) - то не было бы такой детерминированности: в java деструктор вызывается тогда, когда программа посчитает, что на объект больше нет ссылок; а посчитает он это тогда, когда это заметит; а когда заметит -- ну... тогда, когда заметит.

Деструктор по-умолчанию всегда сам генерируется, компилятор в любом случае сгенерирует дефолтный деструктор, но иногда он будет делать несовсем то, что нужно вам. Дефолтный деструктор просто вызывает dtor для всех полей класса в порядке обратном объявлению.

Например, если тут не написали бы dtor (или написали бы `~String () = default;`

```cpp
  class String {
    public:
      String (size_t n, char symb) : arr(new char[n + 1]), sz(n), cap(n + 1) {
        /* ... */
      }
  }
```

то тогда произошла бы утечка памяти (потому что delete не сделал высвобождение памяти, а просто вызывал для всех полей dtor).

**Q1.** Допустим у меня есть dtor, а полями являются какие-то объекты, у которых тоже свои dtor есть и они все нетривиальные - в каком порядке что произойдет? 1) сначала код моего деструктора, а потом деструкторы полей или 2) сначала деструкторы полей, а после код моего деструктора?

**Ответ - 1**. Пока я нахожусь в теле моего деструктора поля еще живы, к ним еще можно обращаться. Они еще не уничтожены. После этого деструктуры остальных полей будут выполнены автоматически после выхода из моего деструктора в обратном порядке объявления.

## 3.3.3 Сopy constructor (copy)

Данный конструктор позволяет сделать объект вашего класса из другого объекта ТАКОГО же класса. Обычно `copy` имеет такую сигнатуру:

```cpp
  String (const String& other) {} // copy
```

Почему ссылка и почему `const`. Понятно, что принимать объект по значению в `copy` - это полный кринж, потому что копирование объекта и описывается `copy`: чтобы передать объект по значению, его нужно было именно скопировать, а копирование мы и хотим определить. Можно было бы принимать в `copy` без слова `const` - так можно (это тоже конструктор копирования - `String(String& other) {}`), но такое редко бывает нужно: обычно копирование константных объектов не отличается, и чтобы `copy` работал и для константатных и для НЕконстантных объектов - сразу пишем `const`. Хотя бывает, что для константатных и НЕконстантных объектов нужно по-разному объявлять конструктор копирования (но это очень редко).

Компилятор тоже умеет генерировать `copy` по-умолчанию, даже если у вас есть НЕтривиальные `ctor`. Как он выглядит? Просто скопировать значения всех полей по-элементно. Для тупых классов, вроде `Complex` выше - `copy` дефолтный подходит. Но для `string`, где у нас выделяется динамическая память и заполняется чем-то - тут уже не подходит дефолтный `copy`.

Для конструтора `copy` так же можно написать `=default`.
Но давайте полноценный напишем для `String`

```cpp
  class String {
    public:
      String (size_t n, char symb) : arr(new char[n + 1]), sz(n), cap(n + 1) {
        /* ... */
      }
      String (const& String other) : arr(new char[other.cap]), sz(other.sz), cap(other.cap) {
        memcpy(arr, other.arr, sz + 1)
                  //
                  // работает так же, как std::copy
                  // обе написаны так, что если примитивные типы, то
                  // он копирует машинными словами (по 8 байт, а не 1 байт)
                  // 
                  // если НЕпиритивный тип, например vector<std::string>, то
                  // memcpy - нельзя вызывать, нужно std::copy
                  //
                  // std::copy копирует честно - ВЫЗЫВАЕТ КОНСТРУКТОРЫ COPY
                  // а memcpy просто по байтам копирует память
                  // - для примитивный типов ОК, а для НЕпритивных - НЕок
                  //
                  // есть еще strcpy - она по 1 байту работает -> не эффект.
                  //
                  // есть еще memmove - он делает тоже копирование,
                  // но он дает гарантию, что если диапозоны пересекались,
                  // то все будет корректно
                  // 
      }
  }
```

## 3.3.4 Constructor Delegation (delg)

Бывает так, что много конструкторов делают одно и то же, но различаются условно в последнем действии. Мы можем сказать `ctor` - сначала сделай то, что сделал бы вот тут конструктор, а потом сделай еще кое-что.

```cpp
  class String () {
    private:
      String (size_t n) : arr(new char[n+1]), sz(n), cap(n+1) { // delg
        arr[sz] = '\0';
      }
    public:
      String (size_t n, char c) : String(n) {
                      //
                      // вот тут происходит делегирование
                      // если уже вызывали delg, то теперь
                      // нельзя делать дальше инициализацию полей в mem-list
                      //
        memset(arr, c, n);
      }
  }
```

Заметьте, что тут `delg` приватный. 

**Q2.** У нас мог бы быть еще конструтор от `char`, который делал бы строку из одного символа: что произошло бы, если я написал тогда `String(100)` - `CE` или создатся строка из одного символа `d`. 

**Ответ** -- т.к. приватность проверяется после перезгрузки, то если есть конструктор от числа приватный, и конструктор от `char` публичный, то когда мы вызовемся от числа - будет `CE`, а не ковертацию числа в символ.

**Q3.** Что будет если написать тут `String s = s;`?

**Ответ** -- вызовется конструктор копирования строки от себя самой. Имя переменной вступает в действие сразу после знака `=`. Поэтому `int x = x` -- это все равно, что написать `int x`. В случае с классами это работает чуть иначе, тут будет вызыван конструктор копирования в таком случае. То есть честно вызовется `copy`. У нас еще поля непроиницизированы, то мы уже инициализируем себя значениями своих полей. Это будет вообще `UB` т.к. мы пытается инициализировать `string` полем `sz` которое и есть мое поле `sz`, но т.к. поле еще не проиницилизировано, то это `UB`. 

### Сopy-on-write (COW)

Смысл: конструктор копирования оставляется тривиальным, а реальное копирование делается тогда, когда-то кто-то пытается изменить копию. Это такое линивое копирование. Когда вас попросили скопировать - вы еще ничего не скопировали, вы переприсвоили поля и запомнили, что вы не единственный, кто на эту строку указывает. А КОГДА вы попытались туда что-то записать, вот тогда вы начинаете делать копию: вы поняли, что вас хотят изменить, а вы не единственный - значит вам нужно копироваться в этот момент. 

### =delete

Наряду с `=default` про методы можно написать `=delete`. Так нужно писать, если вы хотите запретить вызов метода с такими параметрами. Например, можно запретить конструктор по умолчанию: `String () = delete;`

Если вы сделали метод `= delete` от парметра с `size_t` и оставили публичный метод с `char`, то тогда вызываясь от `size_t` - перезгрузки не будет, будет `CE`, потому что явно запретили. До `Cpp11` не было `=delete`, так что для запрета вызываться от конкретных параметров, метод приходилось делать приватным.

`=default` можно писать и для обычный функций, не методов класса.

## 3.3.5 Assignment operator (assi)

Оператор присваивания компилятор тоже умеет генерировать самостоятельно. В нашем классе `String` при дефолтном присвивании будет опять же по-элементным копированием полей (как было у нас с `copy` -- та же самая проблема -> та же необходимость самостоятельно определять нетривиальный `assi`).

Это уже не конструктор, тут иной синтаксис:

```cpp
  String& operator= (const String& other) {}
                //
                // тут именно ссылка на String
                // почему не void? не могли бы присваивать строки подряд
                // типа s1 + s2 + s3
                //
                // почему не просто String (без ссылки)? тогда приходилось бы
                // копироваться всякий раз при возврате из оператора присваивания
                //
                // почему не const String&? потому что хотим уметь метнять то, что
                // вернули, хотим присваивать тому, что получилось
                //
```

Давайте сначала реализуем плохо `assi`, потом сделаем хорошо :)

```cpp
  String& operator= (const String& other) {
    delete[] arr;
    sz = other.sz;
    cap = other.cap;
    arr = new char[other.cap];
    memcpy(arr, other.arr, sz + 1);
    return *this; // не забываем, т.к. это не конструктор
                  // this - это указатель на себя
                  // поэтому делаем разыменование
  }
```

Вроде нормальный код. Будет работать. Некоторые могут подумать, а зачем делать `delete[] arr;`, если можно вызывать `this->~String()`? Это `UB`. Потому что деструктор любого объекта должен быть вызыван лишь один раз в программе, а если несколько раз - это UB. На сложных задачах все это будет падать, если `-O2` - компилятор думал: _ааа, уже вызван деструктор, ну значит можно дальше не читать))) объект уничтожен_.  Если и писать так, то `delete[] arr;`. 

**Но что будет, если сделаем присваивание самому себе? Просто удалим себя.** Например, если хотим присвоить результат вызова функции, которая возвращает ссылку на вас же. Так что тут нужна проверка, не присваиваем ли мы самому себе. Как это проверить?

```cpp
  String& operator= (const String& other) {
    if (this == &other) return *this;
        // проверяем МЫ ЛИ ТОТ ОБЪЕКТ, КОТОРЫЙ ХОТИМ ПРИСВОИТЬ
        // а для этого проверяем по совпадению адреса в памяти
        // не совпадание данных, а именно адрес
    /* ... */
  }
```

Но это все можно написать проще и короче, благодаря идиоме `сopy and swap`.

### Copy and swap

Для этого необходимо реализовать еще метод `swap` за `O(1)`. А почему за `O(1)`? Потому что вот тут можно просто поля `swap` сделать. Но `O(1)` именно с тривиальными полями (как у нас -- два числа и указатель).

```cpp
  void swap(String& other) {
      std::swap(arr, other.arr);
      std::swap(sz, other.sz);
      std::swap(cap, other.cap);
  }
```

Теперь можно вот так:

```cpp
  String& operator= (const String& other) {
    String copy = other;
    swap(copy);
    return *this;
  }
```

Можно еще короче это написать, а именно:

```cpp
  String& operator= (String other) {
    swap(other);
    return *this;
  }
```

## 3.4 Rule of three

```

```
