## 3.5 Const, mutable, static и explicit в методах классов

### 3.5.1 Const

Представим, что у нас есть вот такая структура:

```cpp
  struct S {
    void f() {
      std::cout << "Hello world!";
    }
  };
```

Теперь если мы создадим `const S s;` и после вызовем `s.f();` - мы получим `CE`. 

**Почему так? Потому что в C++ все методы, про которые ЯВНО не сказали что они доступны для `const` объектов - считаются недоступными для них.** Приходится постоянно, если хотите чтобы метод вызывался и у const и у ни НЕ const объектов, дополнить указывать следующее:

```cpp
  struct S {
    void f() const { //
                     // вот тут указываем через слово const
                     // теперь метод можно вызывать
                     // и для НЕ const и для const объектов
                     // 
      std::cout << "Hello world!";
    }
  };
```

Помните про понимание константности в C++. Константные объекты это те - над которыми часть операций недоступна. Вот вам и проявление: если объявили объект типа `const` - то для него недоступны по-умолчанию никакие методы (тут _метод_ = _операций_ в смысле _функции_), а доступными может быть лишь часть методов, которые явно разрешили вот так `void f() const {...}`. Некоторые полагают, что это ошибка в дизайне языка. Создатели `Rust` кажется так же считали, поэтому там все наоборот сделали.
