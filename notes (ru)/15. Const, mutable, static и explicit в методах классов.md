## 3.5 Const, mutable, static и explicit в методах классов

### 3.5.1 Const

Представим, что у нас есть вот такая структура:

```cpp
  struct S {
    void f() {
      std::cout << "Hello world!";
    }
  };
```

Теперь если мы создадим `const S s;` и после вызовем `s.f();` - мы получим `CE`. Даже если создадим `S s` и после константную ссылку `const S& r = s;` и вызовем `r.f();` - то все равно будет `CE`, разумеется, потомк что нет разницы от обращения к самому объекту или к ссылке на него, важно что тип - это константность.

**Почему так? Потому что в C++ все методы, про которые ЯВНО не сказали что они доступны для `const` объектов - считаются недоступными для них.** Приходится постоянно, если хотите чтобы метод вызывался и у const и у ни НЕ const объектов, дополнить указывать следующее:

```cpp
  struct S {
    void f() const { //
                     // вот тут указываем через слово const
                     // теперь метод можно вызывать
                     // и для НЕ const и для const объектов
                     // 
      std::cout << "Hello world!";
    }
  };
```

На глубинном уровне в функцию в качестве скрытого `нулевого` аргумента передается параметр `this` (т.е. ссылку на объект, почти как в `self` в `Python`). И когда мы вызываем констнатный объект - мы передаем константный `this` в неконстнатную фукцию, так что как бы делаете неявный каст из `const` в `НЕconst`, а это запрещено.

Помните про понимание константности в C++. Константные объекты это те - над которыми часть операций недоступна. Вот вам и проявление: если объявили объект типа `const` - то для него недоступны по-умолчанию никакие методы (тут _метод_ = _операций_ в смысле _функции_), а доступными может быть лишь часть методов, которые явно разрешили вот так `void f() const {...}`. Некоторые полагают, что это ошибка в дизайне языка. Создатели `Rust` кажется так же считали, поэтому там все наоборот сделали.

Вывод: при проектировании класса, если вы предполагаете, что метод может вызываться и у константных, и у НЕконстантных объектов - нужно помечать словом `const`; e.g. делаете класс `String` и определяете метод `size()`, его должны сделать `const`, т.к. иначе нельзя будет спрашивать `size()` у константных строк.

К конструкторам и деструкторам - это никакого отношения не имеет.

Разумеется дело не только в слове `const` и кое-какие ограничения накладываются в `compile time`. **В константных методах НЕЛЬЗЯ менять поля; т.е. нельзя вызывать НЕконстантные операции у них.**

```cpp
  struct S {
    int x = 0; 
    void f() const {
      ++x; // вот так вот нельзя
    }
  };
```

**Q1.** Можно ли сделать вот так?

```cpp
  struct S {
    void f() const {
      std::cout << "1";
    }
    void f() {
      std::cout << "2";
    }
  };
```

**МОЖНО**. Можно делать перегрузку по констнатности, причем по констаности объекта самого, т.е. `this` (точно так же, как можно делать перегрузку и по параметрам). Таким образом, если вызываться от констнатных объектов - то вывод `1`, а если от НЕконстнатных объектов - то вывод `2`.

**Q2.** Как правильно реализовывать оператор `[]`, например в `String`?

```cpp
  struct S {
    char arr[10];
    char& operator [](size_t index) {
                     //
                     // тут возвращаем именно ссылку, потому что хотим, чтобы
                     // был lvalue, причем такое, чтобы присваивание меняло именно
                     // тот самый char который в массиве лежал, а не локальный
                     //
      return arr[index];
    }
  };
```

Вот в данном случае будет `CE`, если мы вызовемся от константного объекта `S`. Поэтому первая идея, которая приходит - сделать `[]` методом `const`.

```cpp
  char& operator [](size_t index) const {...}
```

Логично, казалось бы: ведь квадратные скобочки не меняют объект, так что нормально. НО это НЕправильная интуиция (констностность - это не нечто, что НЕ меняет объект). Потому что суть вызова у `const S` оператора `[]` в том, чтобы нельзя было менять возвращаемое значение функции, то есть вот тот элемент массива. Поэтому нужно:

```cpp
  char& operator [](size_t index) {...}
  const char& operator [](size_t index) const {...}
```

Вот такие две реализации нужно писать.

А почему (раз нам при const нужно чтобы не менялся объект) бы не возвращать `rvalue`.

```cpp
  char operator [](size_t index) const {...}
```

Ну потому что тогда не будет работать взятие адреса от результата квадратных скобочек. Но есть более хитрый пример, на одной из лекций другого курса придумали (при такой реализации через `rvalue`):

```cpp
  int main() {
    String s = "abcd";
    const String& cs = s;
    const char& c = cs[0]; // c указывает на временный char (rvalue)
                           // как раз поэтому тут const ссылка (только тогда можно на rvalue)
    s[0] = 'b';            // изменяем исходный массив
    assert(c == 'b');      // но ссылка всё ещё указывает на старую копию, а не на новый символ в массиве
                           // поэтому хотя тут можно ожидать true, но будет false
  }
```

Некорректно будет работать, если реализовывать через `rvalue` оператор.

#### Как работают поля-указатели?

В `const` функции нельзя менять именно поля, а раз поле-указатель, то внутри

```cpp
  char* arr;
  void f() const {
    // вот тут внутри char* arr превращается именно в char* const arr;
  }
```

превращается именно в константный указатель, то есть именно указатель нельзя менять (переуказывать), но не значение под ним. Поэтому не получится вот такое: 

```cpp
  char* arr;
  void f() const {
    ++arr;
  }
```

Но при обращении 

```cpp
  char* arr;
  char& f() const {
    return arr[0]; // вот тут вот
  }
```

вернется неконстаное значение и это скомпилируется, потому что само значение все так же не const.

#### Как работают поля-ссылки?

Вот тут интуиция ломается.

```cpp
  int x = 0;
  struct S {
    int& r = ::x;
    void f(int y) const {
      r = y; // можно ли вот так делать?
             // изменять глобальный x
    }
  };
```

Будет ли это компилироваться. **Да, будет**. Но, к сожалению, тут ломается интуиция о ссылке. Когда речь идет о навешивании константности на ссылку. Вот тут, компилятор должен навестить const на все поля, а тут полем является ссылка. **Поскольку ссылка она по факту указатель в данном случае, то const для ни на что не влияет**. И как бы const навешивается неявно справа, хотя так и нельзя делать - это `CE`. Потому что неизменными должны быть те байты, которые кодируют ссылку, а не то, что будет если ее разыменовать. 

**Поэтому для ссылок в `const` методах вообще нет разницы** и вот такое даже компилируется:

```cpp
  struct S {
    int x = 1;
    int& r = x;
    void f(int y) const {
      r = y; // все ОК
    }
  };
```

Мы получили `НЕconst` ссылку на `const` поле. Теперь можно **менять у констаного `S`** значение поля `x`

```cpp
  int main () {
    const S s;
    s.f(2);
    std::cout << s.x; // 2
  };
```

### 3.5.2 Mutable

= 00:29:00
