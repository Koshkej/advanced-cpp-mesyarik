## 3.5 Const, mutable, static и explicit в методах классов

### 3.5.1 Const

Представим, что у нас есть вот такая структура:

```cpp
  struct S {
    void f() {
      std::cout << "Hello world!";
    }
  };
```

Теперь если мы создадим `const S s;` и после вызовем `s.f();` - мы получим `CE`. Даже если создадим `S s` и после константную ссылку `const S& r = s;` и вызовем `r.f();` - то все равно будет `CE`, разумеется, потомк что нет разницы от обращения к самому объекту или к ссылке на него, важно что тип - это константность.

**Почему так? Потому что в C++ все методы, про которые ЯВНО не сказали что они доступны для `const` объектов - считаются недоступными для них.** Приходится постоянно, если хотите чтобы метод вызывался и у const и у ни НЕ const объектов, дополнить указывать следующее:

```cpp
  struct S {
    void f() const { //
                     // вот тут указываем через слово const
                     // теперь метод можно вызывать
                     // и для НЕ const и для const объектов
                     // 
      std::cout << "Hello world!";
    }
  };
```

На глубинном уровне в функцию в качестве скрытого `нулевого` аргумента передается параметр `this` (т.е. ссылку на объект, почти как в `self` в `Python`). И когда мы вызываем констнатный объект - мы передаем константный `this` в неконстнатную фукцию, так что как бы делаете неявный каст из `const` в `НЕconst`, а это запрещено.

Помните про понимание константности в C++. Константные объекты это те - над которыми часть операций недоступна. Вот вам и проявление: если объявили объект типа `const` - то для него недоступны по-умолчанию никакие методы (тут _метод_ = _операций_ в смысле _функции_), а доступными может быть лишь часть методов, которые явно разрешили вот так `void f() const {...}`. Некоторые полагают, что это ошибка в дизайне языка. Создатели `Rust` кажется так же считали, поэтому там все наоборот сделали.

Вывод: при проектировании класса, если вы предполагаете, что метод может вызываться и у константных, и у НЕконстантных объектов - нужно помечать словом `const`; e.g. делаете класс `String` и определяете метод `size()`, его должны сделать `const`, т.к. иначе нельзя будет спрашивать `size()` у константных строк.

К конструкторам и деструкторам - это никакого отношения не имеет.

Разумеется дело не только в слове `const` и кое-какие ограничения накладываются в `compile time`. **В константных методах НЕЛЬЗЯ менять поля; т.е. нельзя вызывать НЕконстантные операции у них.**

```cpp
  struct S {
    int x = 0; 
    void f() const {
      ++x; // вот так вот нельзя
    }
  };
```

**Q1.** Можно ли сделать вот так?

```cpp
  struct S {
    void f() const {
      std::cout << "1";
    }
    void f() {
      std::cout << "2";
    }
  };
```

**МОЖНО**. Можно делать перегрузку по констнатности, причем по констаности объекта самого, т.е. `this` (точно так же, как можно делать перегрузку и по параметрам). Таким образом, если вызываться от констнатных объектов - то вывод `1`, а если от НЕконстнатных объектов - то вывод `2`.

**Q2.** Как правильно реализовывать оператор `[]`, например в `String`?

```cpp
  struct S {
    char arr[10];
    char& operator [](size_t index) {
                     //
                     // тут возвращаем именно ссылку, потому что хотим, чтобы
                     // был lvalue, причем такое, чтобы присваивание меняло именно
                     // тот самый char который в массиве лежал, а не локальный
                     //
      return arr[index];
    }
  };
```

Вот в данном случае будет `CE`, если мы вызовемся от константного объекта `S`. Поэтому первая идея, которая приходит - сделать `[]` методом `const`.

```cpp
  char& operator [](size_t index) const {...}
```

Логично, казалось бы: ведь квадратные скобочки не меняют объект, так что нормально. НО это НЕправильная интуиция (констностность - это не нечто, что НЕ меняет объект). Потому что суть вызова у `const S` оператора `[]` в том, чтобы нельзя было менять возвращаемое значение функции, то есть вот тот элемент массива. Поэтому нужно:

```cpp
  char& operator [](size_t index) {...}
  const char& operator [](size_t index) const {...}
```

Вот такие две реализации нужно писать.

А почему (раз нам при const нужно чтобы не менялся объект) бы не возвращать `rvalue`.

```cpp
  char operator [](size_t index) const {...}
```

Ну потому что тогда не будет работать взятие адреса от результата квадратных скобочек. Но есть более хитрый пример, на одной из лекций другого курса придумали (при такой реализации через `rvalue`):

```cpp
  int main() {
    String s = "abcd";
    const String& cs = s;
    const char& c = cs[0]; // c указывает на временный char (rvalue)
                           // как раз поэтому тут const ссылка (только тогда можно на rvalue)
    s[0] = 'b';            // изменяем исходный массив
    assert(c == 'b');      // но ссылка всё ещё указывает на старую копию, а не на новый символ в массиве
                           // поэтому хотя тут можно ожидать true, но будет false
  }
```

Некорректно будет работать, если реализовывать через `rvalue` оператор.

#### Как работают поля-указатели?

В `const` функции нельзя менять именно поля, а раз поле-указатель, то внутри

```cpp
  char* arr;
  void f() const {
    // вот тут внутри char* arr превращается именно в char* const arr;
  }
```

превращается именно в константный указатель, то есть именно указатель нельзя менять (переуказывать), но не значение под ним. Поэтому не получится вот такое: 

```cpp
  char* arr;
  void f() const {
    ++arr;
  }
```

Но при обращении 

```cpp
  char* arr;
  char& f() const {
    return arr[0]; // вот тут вот
  }
```

вернется неконстаное значение и это скомпилируется, потому что само значение все так же не const.

#### Как работают поля-ссылки?

Вот тут интуиция ломается.

```cpp
  int x = 0;
  struct S {
    int& r = ::x;
    void f(int y) const {
      r = y; // можно ли вот так делать?
             // изменять глобальный x
    }
  };
```

Будет ли это компилироваться. **Да, будет**. Но, к сожалению, тут ломается интуиция о ссылке. Когда речь идет о навешивании константности на ссылку. Вот тут, компилятор должен навестить const на все поля, а тут полем является ссылка. **Поскольку ссылка она по факту указатель в данном случае, то const для ни на что не влияет**. И как бы const навешивается неявно справа, хотя так и нельзя делать - это `CE`. Потому что неизменными должны быть те байты, которые кодируют ссылку, а не то, что будет если ее разыменовать. 

**Поэтому для ссылок в `const` методах вообще нет разницы** и вот такое даже компилируется:

```cpp
  struct S {
    int x = 1;
    int& r = x;
    void f(int y) const {
      r = y; // все ОК
    }
  };
```

Мы получили `НЕconst` ссылку на `const` поле. Теперь можно **менять у констаного `S`** значение поля `x`

```cpp
  int main () {
    const S s;
    s.f(2);
    std::cout << s.x; // 2
  };
```

### 3.5.2 Mutable

Иногда бывает, что в const методе все же хочется поменять поле. `Const` - это лишь абстракция времени компиляции, если мы говорим про классы (примерно как приватность), потому что глобальные констнаты это более низкоуровневая вещь. `Const` - это просто контракт, который вы сами себе навесели, чтобы случайно не нарушить логику, но иногда вам будет хотеться нарушить эту логику. Для этого есть слово `mutable`.

```cpp
    mutable int x = 5; // вот такое "противоядие" против const
                       // теперь этот x никогда не будет константным
```

Слово `mutable` бывает почаще полезнее чем `friend` даже, иногда используют в продакшене. 

Простой пример. Отладка чего-то и вы хотите вести счетчик вызовов методов класса. С точки зрения пользователя объект класса не изменяется, но физически объект изменяться будет (счетчик будет увеличиваться). Поэтому для const методов нужно делать поле-счетчик невосприимчивым к const. 

### 3.5.3 Static

#### Статические методы

Может быть нужно, чтобы метод относился не к объекту, а ко всему классу целиком. 

_Например: создаете класс длинной арифметики (BigInteger); при делении длинных чисел бывает удобным повернуть их задом-наперед, так что нужно сделать функцию, которая будет делать разворот вашего длинного числа; это может быть нетривиально, потому что какие-то биты у вас могут не до конца быть заполнеными (потому что реализация идет по чанкам - 8 байт), тогда нужно это учитывать. Вот есть метод "развернуть число" и этот метод не относится к вашему конкретному объекту, он относится к классу в целом, это не метод вашего объекта. Это метод, который вы вызываете над массивом. _

```cpp
  struct S {
    static void f() { // вот этот метод не относится
                      // к какому-либо конкретному объекту
                      // он относится к классу в целом
      std::cout << "Hi!";
    }
  }
```

Как такими методами пользоваться? Они работают как просто функции, которые объявлены в пространстве имен класса

```cpp
  int main () {
    S::f(); // никакой объект не будет создан
            // вы просто вызовете эту функцию
  }
```

#### Статические поля

Это переменные, которые находятся в области видимости класса, но относятся к классу. Класс для них - это просто `namespace` по сути. Они просто существуют и все. Мы раньше называли `static` - то, что хотим положить в статическую память. Для полей `static` смысл тот же самый. 

```cpp
  struct S {
    static int x; // в области видимости S как в namespace
                  // объявили переменную x в статической памяти
  }
```

По поводу статических переменных еще важное. Есть их два вида. Первые - которые инициализируются сразу, тогда в бинарники программы будет буквально зашито все их содержание и они загрузятся сразу в момент запуска программы. Вторые - которые инициализируются во время выполнения программы, тогда в бинарнике будет лишь их размерность, и когда вы будете их заполнять, тогда выделиться необходимая `data` память, равная этой размерности.

_Например в BigInteger. Может быть нужно поле `base` - там хранится основание системы счисления. Или поле размера чанка. Они относятся к классу, а не к конкретному объекту. _

Пример класс `singleton`, который может существовать лишь в единственном экземпляре, его нельзя копировать, оно одно должно существовать. Должно быть: можно к нему обратиться, а если его нет - надо создать новое. Как это делается?

```cpp
  struct Singleton {
    private:
      Singleton() {}
      static Singleton* ptr;                          // храним указатель на объект
      Sigleton(const Singleton&) = delete;            // запрет копирования 
      Sigleton& operator=(const Singleton&) = delete; // запрет присвоения 
    public:
      static Singleton& getObject() {
        if (ptr == nullptr) {                        // проверяем был ли уже создан объект
          ptr = new Singleton();
        }
        return *ptr;
      }
      // понятное дело, что тут еще нужно сделать метод, который вызовет деструктор
  };
  Singleton* Singleton::ptr = nullptr;
```

Теперь можно сказать:

```cpp
  int main () {
    Singleton& Object = Singleton::getObject();
  }
```

**Странность со статическими полями**

Нельзя написать вот так `static int x = 5;`. Это будет `CE`. Стандарт запрещает внутриклассовую инициализацию статических полей класса. Иначе могут быть проблемы при линковки.

Вот так нужно: `int S::x = 1;` вовне класса.

А вот так `static const int x = 5;` - можно (и const статик вроде сразу в бинарник зашивается). 

Такие правила. 

### 3.5.1 Explicit & Implicit 

Как переводится `Explicit` с английского? Явный, неприкрытый. `Implicit` - его противоположность. 

Это ключевое слово используется для методов, которые вы хотите запретить неявно вызывать. Такими методами могут быть конструкторы и операторы приведения типов. 

#### Explicit операторы приведения типов

Для чего могут быть нужны операторы приведения типов? Язык C++ является языком со строгой типизацией, поэтому нам можем хотитеться, чтобы числа какие-нибудь, хотя и являются int, но были разными типами. Зачем нужны разные типы, если это все int все равно? Это нужно, чтобы случайно не передать не тот тип, что ожидается. Строгая типизация она как раз очень помогает избежать ошибок из-за того, что все `int` в параметрах, но важно что первый int это чатID, второй int это юзерID и так далее. Вы перепутали числа, но все скомпилировалось и потом упало. И вот статическая типизация может помочь избежать проблем: делаете int разными типами и теперь в неправильном порядке вы их не передадите.

Пример. В Яндекс Такси есть такие замечательные типы как точка на карте и там нужно точку задавать двумя координатами - широта и долгота. Вопрос, что должно быть первым? И то и другое `double`. Любый разработчик хотя бы раз в своей практике выесняет, что у него точка в Иране находится, а не в Москве (у них противоположные широта и долгота). Короче, если есть несколько **семантически** разных типов, хотя физически они представляются одинаково, то строгая типизация как раз дает возможность избежать опасности перепутать аргументы.

Для таких целей можно завести отдельные классы, которые оба всего-лишь содержат double:

```cpp
  struct Latitude {
    double value;
    Latitude(double value) : value(value) {}
  }
  struct Longitude {
    double value;
    Longitude(double value) : value(value) {}
  }
```

Но нужно сделать так, чтобы нельзя было НЕявно перекоставать к `double` ничего из этого. По-умолчанию компилятор, если где-то ожидается Latitude или Longitude будет НЕявно конвертировать к `double`. Нужно запретить это. Чтобы всякий раз, когда я пытаюсь отдать в качестве параметра то, что ожидает широту или долготу, мне приходилось бы явно говорить, что я имею в виду сейчас `Latitude` или `Longitude`.

Для этого:

```cpp
  struct Latitude {
    double value;
    explicit Latitude(double value) : value(value) {}
  }
  struct Longitude {
    double value;
    explicit Longitude(double value) : value(value) {}
  }
```

Слово `explicit` пишется перед конструктором и запрещает неявно вызывать этот конструктор. Теперь, если кто-то ожидает тип `Latitude` или `Longitude`, а вы передаете туда `double`, то тогда не будет рассматриваться вариант неявной конверсиии из `double` в `Latitude` или `Longitude`.

Еще есть операторы приведения типов. C++ позволяет их переопределять.

Например. Хотим уметь из `Latitude` получать обратно `double`, допустим, хотим именно конвертировать `Latitude` чтобы получить `double`. Как пишется оператор приведения типов?

```cpp
  struct Latitude {
    operator double() const { // не пишем возвращаемое значение
      return value;
    }
  }
```

Теперь мы разрешили приведения от `Latitude` к `double`. Сейчас `operator double` написан так, что его можно вызывать НЕявно, то есть если какая-то функция принимает `double`, а я передаю `Latitude` - будет неявная конверсия. Начиная с Cpp11 можно написать `explicit` и для оператора приведения типов. 

```cpp
  struct Latitude {
    explicit operator double() const {
      return value;
    }
  }
```

Теперь он не будет рассматривать неявную конверсию из `Latitude` в `double`. Чтобы теперь вызывать реально, нужно вызывать `static_cast`. Для своих типов мы доопределяем операторы приведения типов. 

По кодстайлу рекомендуется, если у вас есть конструктор от одного параметра - делать его `explicit`. Операторы приведния типов тоже рекомендуется делать `explicit`.

**Небольшой костыль**

Конверсии бывают явные (`explicit)`, неявные (`implicit`) и **еще `contextual`**. Это та самая конвертация, которая проиходит под `if`, `while` и в тернарном операторе. Этот вид конверсии, которые разрешает и explicit конверсии рассматривать.

Начиная с Cpp11 можно получить объект вашего класса из числа - литеральные суффиксы. Например, когда мы пишем `2.0f` - тут `f` это литирал к `float`. После Cpp11 можно определять кастомные. Для этого нужно определить оператор `""`. Как это делается?

```cpp
  struct Latitude {
    Latitude operator""_lat (long double x) {
                                // по кодстайлу пишем _ для того, чтобы явно указать на кастомность
                                // параметр -- либо unsigned long long / char* / long double
                                // потому что литералы могут быть длинными и раз уж вы определяете
                                // то должны взять максимально длинный 
      return Latitude();
    }
  }

  int main () {
    Latitude ex = 55.0_lat;
  }
```

Да, кстати, есть литералл для `std::string` строки (а не `С-строки`) - `"abcded"s;`. 
