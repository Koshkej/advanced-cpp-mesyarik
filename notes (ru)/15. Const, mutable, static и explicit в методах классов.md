## 3.5 Const, mutable, static и explicit в методах классов

### 3.5.1 Const

Представим, что у нас есть вот такая структура:

```cpp
  struct S {
    void f() {
      std::cout << "Hello world!";
    }
  };
```

Теперь если мы создадим `const S s;` и после вызовем `s.f();` - мы получим `CE`. Даже если создадим `S s` и после константную ссылку `const S& r = s;` и вызовем `r.f();` - то все равно будет `CE`, разумеется, потомк что нет разницы от обращения к самому объекту или к ссылке на него, важно что тип - это константность.

**Почему так? Потому что в C++ все методы, про которые ЯВНО не сказали что они доступны для `const` объектов - считаются недоступными для них.** Приходится постоянно, если хотите чтобы метод вызывался и у const и у ни НЕ const объектов, дополнить указывать следующее:

```cpp
  struct S {
    void f() const { //
                     // вот тут указываем через слово const
                     // теперь метод можно вызывать
                     // и для НЕ const и для const объектов
                     // 
      std::cout << "Hello world!";
    }
  };
```

Помните про понимание константности в C++. Константные объекты это те - над которыми часть операций недоступна. Вот вам и проявление: если объявили объект типа `const` - то для него недоступны по-умолчанию никакие методы (тут _метод_ = _операций_ в смысле _функции_), а доступными может быть лишь часть методов, которые явно разрешили вот так `void f() const {...}`. Некоторые полагают, что это ошибка в дизайне языка. Создатели `Rust` кажется так же считали, поэтому там все наоборот сделали.

Вывод: при проектировании класса, если вы предполагаете, что метод может вызываться и у константных, и у НЕконстантных объектов - нужно помечать словом `const`; e.g. делаете класс `String` и определяете метод `size()`, его должны сделать `const`, т.к. иначе нельзя будет спрашивать `size()` у константных строк.

