### using для переменных
Можно объявлять `using`

*`using` - это слово, с помощью которого мы можем либо переобъявить то, что мы уже раньше объявляли, но уже в новой области видимости*

#### Как работает using?
Если я захочу использовать `x` из `namespace`, то мне придется писать `N::x`. Если я просто напишу `x`, то будет не понятно что это за `x` - вылетит ошибка `'x' was not declared in this scope` - `x` был не объявлен в данной области видимости

То, что ограничено фигурными скобками - называется *`scope` (областью видимости)*. Он бывает локальный и глобальный (возможен еще один вариант, но о нем позже)

То что мы объявили в глобальном `scope` видно везде

Но наш `x` объявлен не глобально, он объявлен в пространстве имен и поэтому, чтобы к нему обратиться нужно указать, откуда мы его берем `N::x`

Но мы еще можем сказать, что я хочу этот `x` привнести в эту область видимости - я хочу сказать, что `x`, который из пространства имен `N` пусть в рамках текущей области видимости называется просто `x`, чтобы не писать каждый раз `N::`
```cpp
#include <iostream>

namespace N {
    int x;
}

int main() {
    using N::x;
    std::cout << x;
}
```

***вот это `using` для привнесения какого-то имени в данную область видимости***

То же самое могу сказать `using` глобально 
```cpp
#include <iostream>

namespace N {
    int x;
}

using N::x;

int main() {
    std::cout << x;
}
```
Это будет означать, что мы глобально объявили `x` с помощью `using`. Я как бы взял `x` из пространства имен `N` и вынес его наружу. `x` будет тем же самым, но теперь все что ниже этого `using` - если я обращаюсь к `x`, то будет считаться, что я обращаюсь к `x` из пространства имен `N`

Можно делать `using` на любом уровне

Это первый случай использования `using`

### using namespace
Второй случай использования - написать `using namespace`

Когда я пишу `using namespace`, это означает, что все имена, которые были объявлены в этом нэймспейсе отныне выносятся наружу и считаются видимыми в моей области, в которой я написал `using namespace`
```cpp
#include <iostream>

namespace N {
    int x;
}

using namespace N;

int main() {
    std::cout << x;
}
```
Я написал `using namespace N` глобально - это означает, что теперь глобально, все что ниже этого `using namespace` будет видно глобально. Можно считать, что все объявления, которые были в `namespace N` мы повторили на глобальном уровне, но только это не новые сущности, а все сущности из `namespace N` сделали видимыми на глобальном уровне

***Различение имен работает на очень ранней стадии компиляции***

`using namespace` можно написать и локально (внутри какой-то функции). Тогда на уровне этой функции будут видны все сущности из этого неймспейса

***Не рекомендуется писать `using namespace std;` потому что этим действием мы привносим в свою область видимости огромное количество имен, о которых даже не подозреваем, но которые возможно начинают конфликтовать с нашими именами.*** Для имен переменных это еще не так страшно - если конфликт имен переменных, то это CE. А вот если конфликт имен функций, то это проблема, потому что функции умеют перегружаться. Может быть несколько функций с одинаковым именем, но с разными типами принимаемых значений - можем нарваться на очень трудно уловимый баг - вызывать другую версию функцию, а не свою самописную

Такое возможно для функций, классов и для много чего прочего

Если надоедает постоянно писать `std::cout`, то мы можем написать `using` на конкретное имя из `namespace`
```cpp
int main() {
	using std::cout;

	cout << 10;
}
```
теперь наш `cout` будет браться из неймспейса `std` и нам не надо явно указывать, откуда он берется

Начиная с C++17 можно указывать несколько `using` через запятую
### using для типов, typedef
Третий вид `using`, когда делаем алиас для типа
```cpp
int main() {
	using vi = std::vector<int>
}
```
отныне в этой области видимости `vi` это тоже самое, что и `std::vector<int>`

Когда мы пишем `using`, мы не объявляем тем самым новый тип. Мы создаем новое название для того же самого типа `vi` и `std::vector<int>` - это один и тот же тип

Отличие `using` от `typedef` в том, что `using` более интеллектуальный - например, умеет работать с шаблонными типами
```cpp
template <typename T>
using v = std::vector<T>;
```

`typedef` - это C-style объявление и не рекомендуется его использовать

***Лучше использовать `using`, вместо `typedef`.*** Он лучше читаемый и больше умеет

### Понятие ключевых слов (keywords)
Есть слова, у которых предопределённый смысл и им нельзя придать другой смысл. Такие слова называются ключевыми словами

Нельзя имя переменной сделать таким, и их нельзя никак переопределить

Когда компилятор парсит программу у ключевого слова зашитый смысл и он не может быть переопределен

С `define` такое будет работать, но только потому, что `define` работает до компилятора - препроцессор, делает просто текстовую замену. Поэтому с `define` можно заменить что угодно на что угодно. Но когда дело уже дойдет до компиляции там такое уже не сработает

### Вложенные области видимости, затмения глобальных имен локальными именами
В C++ есть понятие области видимости, при этом области видимости вложены друг в друга

Есть глобальная область видимости, в ней фигурные скобочки открывают новые области видимости

Есть:
- global scope
- namespace scope (внутри неймспейса)
- class scope (внутри класса)
- и другие

```cpp
int main() {
	int x = 0;
	for (int i = 0; i < 10; ++i) {
		int x = i;
		std:cout << x;
	}
}
```
***Это не ошибка.*** В C++ можно объявлять более локальные переменные с теми же именами, что и менее локальные переменные

Сейчас этот `x` это локальный `x` для `for`. После того как я объявил этот `x`, внешний `x` (за пределами `for`) он как бы затмился до конца области видимости `for`

До внешнего `x` (за пределами цикла) я никак не могу достучаться

```cpp
int x = 0;

int main() {
	int x = 0;
	for (int i = 0; i < 10; ++i) {
		int x = i;
		std::cout << x; // local scope x
		std::cout << ::x; // global scope x
	}
}
```
В такой ситуации я могу достучаться только до глобального `x` с помощью `::x`

Я всегда могу обратиться к глобальному (самому верхнему) `x` таким способом. Так же я могу обратиться к `x` если он был в каком-то `namespace` или в каком-то классе

Но если был локальный `x` и я его затмил каким-то более локальным, то к менее локальному я уже никак не смогу обратиться никак - для этого нет специального синтаксиса

***То что находится в круглых скобках имеет такой же уровень вложенности, как и переменные внутри фигурных скобок после круглых (то, что внутри `for`)***

### Конфликты имен переменных
Если в том же самом scope попытаться объявить еще один `x`, то это уже будет CE - redeclaration

***В одном и том же scope переменную объявить второй раз с тем же именем нельзя***

Можно просто так открывать фигурные скобки в любом месте и начать что-то в них делать. Это будет новый scope и все будет окей. Так иногда нужно делать, это иногда полезно (*есть функция, у которой есть логические части и мы хотим, чтобы имена в одной части повторяли имена в другой части*). Актуально когда есть объекты, надо чтобы объекты разрушились, а потом создались новые и мы с ними что-то сделали
```cpp
int main() {

	int x = 1;
	{
		int x = 5;
		std::cout << x;
	}
}
```

Когда мы пишем `::` мы явно пишем, откуда надо брать

#### Бывают ситуации, когда обращение к переменной неоднозначно
```cpp
namespace N {
	int x = 7;
}

int main() {
	using namespace N;
	int x = 1;

	std::cout << x;
}
```
`x = 1` (который объявлен в `main`) считается более приоритетным

если сделать вот так, 
```cpp
namespace N {
	int x = 7;
}

int main() {
	using N::x;
	int x = 1;

	std::cout << x;
}
```
то это будет CE, потому что считается что я уже объявил `x` в строчке `using N::x` и я не могу снова объявить `x`

```cpp
namespace N {
	int x = 7;
}

namespace NN {
	int x = 6;
}

int main() {
	using namespace N;
	using namespace NN;

	std::cout << x;
}
```
В таком случае получим ошибку `reference is ambiguous`

Когда мы написали `using namespace` два раза, иксы в обоих неймспейсах считаются равноценными, но это не считается повторным объявлением 

Если какое-то имя я объявляю явно, а какое-то привношу через `namespace`, то приоритетней то, которое я явно привношу
```cpp
int main() {
	using namespace N;
	using NN::x; // приоритетней

	std::cout << x;
}
```

***Правила поиска имен в C++ весьма сложны***

Если написать 
```cpp
int main() {
	using NN::x;
	using x = std::vector<int>;

	std::cout << x;
}
```
будет CE `x redeclared as different kind of entity`

Но если для `using x = std::vector<int>` завести отдельный scope, то все будет в порядке
```cpp
int main() {
	using NN::x;
	{
		using x = std::vector<int>;
	}

	std::cout << x;
}
```

Есть еще интересный пример
```cpp
int x = 0;

int main() {
	int x = x; // x не из global scope

	std::cout << x;
}
```
Существует понятие ***Point Of Declaration - это место в коде, начиная с которого имя действует.*** И в случае объявлений имя начинает действовать сразу же после знака `=`. То есть в примере выше мы присваиваем не значение глобального `x`, а самого же себя из локальной области видимости

Если мы что-то объявляем и говорим, что оно равно самому себе, то это все равно что написать просто `int x` и ничего ему не присвоить

Это UB, потому что нельзя читать переменную до того, как мы ее проинициализировали

### Правила одного определения (ODR)
***One Defenition Rule (ODR) - каждая используемая сущность в программе должна будет ровно один раз определена***

Когда у нас сущность определена несколько раз (или 0 раз) мы получаем ошибку линковки 

Использование функции, которая определена, но не объявлена - это ошибка на стадии линковки, а не компиляции

Это правило звучит иначе для классов:
***Класс можно определить несколько раз, при условии, что все определения дословно идентичны*** (это сделано для того, чтобы можно было заинклудить один и тот же файл несколько раз и это не привело бы к ошибке)

Определение - это когда мы открываем фигурную скобку
```cpp
class C {
 // не важно, что я написал внутри
};
```
выше я уже определил класс

Так решил комитет по стандартизации - если мы написали фигурные скобки, то это определение

Функции нельзя определять несколько раз, можно только один (даже если определение идентично), а классы можно (чтобы можно было инклюдить несколько раз один и тот же хедер)

Объявить функцию можно сколько угодно раз, а определить только один

Если попытаюсь определить функцию второй раз, то это уже ошибка `redefinition`

***Не путать `declaration` и `definition`***

*Инициализация бывает только для переменных*

```cpp
void f(int x); // declaration
void f(int x); // declaration

void f(int x) {} // definition
```

Определять класс в рамках одного `translation unit` (файла) я могу только один раз, но в рамках всей программы сколько угодно раз, при условии, что все определения дословно совпадают

Если бы нельзя было функции объявлять несколько раз, то нельзя было бы сделать перекрестную рекурсию (из `f` вызвать `g`, а из `g` вызывать `f`)
```cpp
void f();
void g() { f(); }
void f() { g(); }
```

Нельзя использовать никакое имя до того, как оно объявлено

***Любое определение является объявлением - когда я что-то определяю, я тем самым его обязательно объявляю.*** Нельзя что-то определить не объявив. Определение всегда является объявлением, а вот обратное не верно

***Внутри класса все методы считаются сразу объявленными***

### Перегрузка функций
Для функций еще существует перегрузка. Функции я могу объявлять и определять с одним и тем же именем, но с разными принимаемыми значениями. И это не будет считаться повторением

Я могу объявлять и определять функцию с таким же именем, но другими принимаемыми значениями - это корректно. Это называется перегрузка функций (`Function Overloading`). С одним и тем же именем у меня может существовать функция, принимающая разные наборы аргументов, и тип при этом у нее может быть разный
```cpp
void f() {}
int f(int x) {
	return x + 1;
}
```

Но объявить функцию с одинаковыми аргументами, но разными возвращаемыми значениями - нельзя

Когда мы вызываем перегруженную версию из кода, компилятор выбирают версию функции в соответствии с переданными в нее аргументами

```cpp
int f(int x) {
	return x + 1;
}

int f(double x) {
	return x + 2;
}

int main() {
	std::cout << f(0.0f);
}
```
В этом случае выберется функция от `double`, потому что `promotion` (расширить тип) лучше, чем `convertion` (преобразовать тип)

Но в ситуации
```cpp
int f(int x) {
	return x + 1;
}

int f(float x) {
	return x + 2;
}

int main() {
	std::cout << f(0.0);
}
```
Будет CE, обрезать передаваемый `double` до `float` или `int` для компилятора равнозначны, они оба считаются `standart conversion` и он не знает что выбрать - вызов функции неоднозначен

`promotion` лучше, чем `convertion`, стандартный `convertion` лучше, чем пользовательский

Неоднозначность выбора имени, обращения к функции/переменной - всегда ошибка компиляции (CE), а не ошибка на этапе выполнения. Потому что именно на этапе компиляции происходит решение, по какому адресу начать выполнять код

***Компилятор обязан для каждого вызова функции превратить его в какой-то прыжок на какой-то адрес выполнения кода. Если он не может этого сделать, то он кидает ошибку на этапе компиляции***

```cpp
void f();
int f();
```
Это `redeclaration` с другим типом возвращаемого значения. Объявить функцию с другим возвращаемым типом я не могу. Мог бы, если бы и принимаемые типы были другими. Если принимаемые типы такие же, а возвращаемый тип другой, то так уже нельзя

```cpp
int main() {
	x; // unqualified-id
	N::x; // qualified-id
}
```
Все имена в совокупности, последовательности символов, которые обозначают какую-то сущность называются идентификаторами

Если обращаюсь к какому-то имени не используя `::` - неквалифицированный идентификатор (`unqualified-id`), а если используя `::` - квалифицированный идентификатор (`qualified-id`)

*На неймспейсы ODR не распространяется*

По стандарту всякое объявление переменной является и ее определением, если только не написано специальное слово, говорящее, что это не так
```cpp
int x; // определил переменную x, но не инициализировал
```

Ключевое слово `extern` позволяет объявить переменную, но не определить. Определение будет где-то в другом месте

Если я хочу зачем-то объявить переменную, но чтобы это не считалось ее определением - пишу `extern`. Это нельзя писать для локальных переменных. Можно писать глобально или в неймспейсах

Через `::` можно делать сколько угодно слоев в неймспейсах

### Понятие выражения (expession)
В глобальном скоупе все, что мы можем написать - это разные объявления 

Но если мы находимся в локальном скоупе (внутри функции), то помимо объявлений мы можем делать еще две вещи:
- писать выражения (expressions)
- писать управляющие конструкции (control statements)

Мы можем это делать только находясь в локальном скоупе. Не можем не в класс скоупе, ни в неймспейс скоупе, только внутри функции

*`statement` - инструкция*
Они бывают:
- `declaration` - объявление новой сущности, `definition` является его частным случаем. Только это и можем писать на глобальном уровне
- `expression`
- `control statement` - `if, for, while и т.д.` - инструкция, которая как-то влияет на поток исполнения

#### expression
Большая часть того, что мы пишем в функциях (примерно поровну с `declaration`)

*`expression` - набор некоторых переменных и литералов, соединенный между собой операторами и скобками*
```cpp
x + 5;
cout << x;
```
Можно составлять сколь угодно длинные `expression`

`;` - это специальный символ, который обозначает границу инструкции

### Арифметические операторы
- `+`
- `-`
- `*`
- `/`
- `%`
- `<<`
- `>>`
- `|`
- `&`
- `^`
- `&&`
- `||`
- `<`
- `>`
- `==`
- `!=`
- `<=`
- `>=`
- `<=>` (начиная с C++20)

Оператор берет левую часть, правую часть, выполняет некоторое действие и возвращает значение

Разница между логическими и побитовыми операторами в том, что побитовые операторы принимают целое число и возвращают целое число, а логические принимают `bool` и возвращают `bool`

### Особенность логических операторов
`&&` и `||` вычисляются лениво. Это гарантируется стандартом

`&&` - правая часть не вычисляется, если левая ложна. Например, `v.size() >= 5 && v[4] == 1` - если размер меньше 5, то мы уже не будем проверять 4 элемент

Гарантируется, что `&&` проверяет на истинность сначала левую часть и только если она истинна, проверяет на истинность правую часть. Гарантируется стандартом, что компилятор не имеет права начать вычислять правую часть, если левая не истина

Аналогично с оператором `||`, только наоборот - если слева истина, то он не пойдет вычислять то, что справа

Это удобно, потому что можем быть уверены, что ничего плохого не произойдет, если какое-то условие не выполнено

### Операторы присваивания и составного присваивания
- `=` - оператор присваивания

Операторы составного присваивания - это операторы вида:
- `+=`
- `-=`
- `*=`
- `/=`
- `%=`
- `<<=`
- `>>=`
- `|=`
- `^=`
- `&=`

Если я решу вывести `x = y`, то вернется то, что получилось после присваивания
```cpp
std::cout << (x = y);
```

Я могу результату присваивания тоже что-то присвоить
```cpp
(x = y) = z;
```
это будет как если бы я присвоил `x` `z`

Мне возвращается не просто значение, которое получилось, а ссылка на то, что получилось. Возвращается прямо вот та самая переменная, которая и получилась

`x = y` - здесь мне возвращается сам `x` и ему снова можно присваивать

### Понятия lvalue и rvalue
Выражения подразделяются на `left` и `right` в зависимости от того можно ли им снова что-то присваивать или нельзя (это очень условно, все гораздо сложнее)

Исторически все выражения подразделяются на `lvalue` и `rvalue`

Могу написать любую последовательность этих присваиваний
```cpp
(x += y) += 5;
```
Получится что я к `x` прибавил `y`, а потом еще к `x` добавил 5 

Составные операторы на выходе дают `lvalue`
