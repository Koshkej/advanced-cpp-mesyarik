*Указатели - это одно из важнейших понятий, пришедших к нам из языка C, играют важную роль в C++*

### Что такое указатель?
У нас есть какая-то переменная, у переменных должно быть какое-то место, где они хранятся в памяти. Значит у каждой переменной есть какой-то адрес в памяти

Данные программы хранятся в оперативной памяти, значит можно спросить номер ячейки в памяти, в которой хранятся эти данные

Для этого используется оператор *унарный амперсанд* `&` - оператор, который по произвольной переменной возвращает адрес ячейки памяти. Адрес в памяти - это число специального типа
```cpp
int x = 0;
std::cout << &x << std::endl;
```
На выходе получим шестнадцатеричное число

Тип у этого выражения `int*`. Можно завести переменную такого типа
```cpp
int* p = &x;
```
`*` - это часть типа, `&` - это оператор

Существует обратная операция ко взятию адрес - разыменование. Если у нас есть переменная типа `T*`, то я могу спросить - *а что под ней лежит?* 

Для этого существует оператор *унарная звездочка* `*`
```cpp
int* p = &x;
std::cout << *p << std::endl; // Dereference
```

Адрес выводится в 16-ричной системе. По существу это просто число, которое обозначает номер ячейки

### Что мы можем делать с типом `int*` ?
- Разыменовывать `*` - получать то, что лежит под ним
- Добавлять и вычитать из него целые числа
```cpp
p + 1
```
Получится новый указатель, численное значение которого отличается от исходного как если бы я сдвинулся от `p` на размер одного `int`
`+: (T*, int) -> T*` - к численному значению `T*` добавляется `sizeof(T) * int`

Делаем шаги размера `sizeof(T)`

Разница между указателями на разные типы в том, что они по разному воспринимают сложение с числами

- Делать инкремент и декремент (префиксный и постфиксный)
```cpp
++p;
--p;
```
При этом указатель сдвинется как если бы к нему добавили единицу

```cpp
std::vector<int> = {1, 2, 3, 4, 5};
int*p = &v[0];
*p; // 1

std::cout << *(++p) << std::endl; // 2
```

***Постфиксный унарный оператор приоритетнее, чем префиксный***

- Можно присваивать указателям новые значения
```cpp
int* p = &y;

int x = 25;
p = &x;
```

- Можно делать `+=` и `-=`
- Можно брать разность двух указателей, если эти указатели одного типа - узнать количество шагов, чтобы дойти от одного указателя до другого. Может быть отрицательной

***Сложение двух указателей не определено***

***`int` лежат по адресам кратным 4***

- Доступны все операции сравнения - просто какое число меньше/больше/равно

### Указатель на указатель
Можно брать указатель на указатель
```cpp
int a = 0;
int* p = &a;
std::cout << p << std::endl;

int** pp = &p;
std::cout << pp << std::endl;

std::cout << *pp << std::endl; // p
std::cout << *p << ' ' << **pp << std::endl; // a a
```

Размер указателя `implementation defined`

Будем жить в предположении, что указатель занимает в памяти 8 байт

Размер указателя не зависит от того, на что он указывает. Это просто 8-ми байтное число, обозначающее ячейку в памяти

Тип указателя влияет на то, какие над ним разрешены операции

Унарная звездочка это `lvalue`, то есть можно делать 
```cpp
*p = 1;
```

Унарный амперсанд возвращает `rvalue`, но требует чтобы его аргумент был `lvalue`. Его можно применять только к переменным, а не к каким-то временным, вычисленным только что значениям

Переменная намертво привязана к ячейке в памяти

***Память под одни переменные может переиспользоваться другими переменными, когда те отмирают (заканчивается их время жизни)***

Указатели на них при этом остаются, но обращение к ним приводит к UB
```cpp
int a = 1;
int* p = &a;
{
	int b = 2;
	p = &b;
}

std::cout << p << '\n';
std::cout << *p << '\n'; // UB
```

***Вычитать и сравнивать указатели разных типов нельзя***

### void*
Особый тип, указатель на неизвестно что. Такой тип, под который можно подложить на что угодно, используется для того, чтобы иметь дело с указателями без уточнения, на что это указатель, просто указатель на какую-то память

Указатели на что угодно неявно приводятся к указателю на `void`

Иногда бывает нужно, если нужен просто указатель на какую-то ячейку памяти, без указания что под ней

***Разыменовать и добавлять числа к `void*` нельзя, потому что непонятно какой тип у этого выражения***

### nullptr
Это 0 в мире указателей. Бывает надо завести указатель, но сначала ничего ему не присваивать

Ключевое слово

У `nullptr` тип `nullptr_t`, который неявно кастуется к любому из указателей

По кодстайлу рекомендуется использовать `nullptr`, а не `NULL`

*Указатели это способ сделать так, чтобы функции могли влиять на переменные, которые существуют вне этих функций*

```cpp
void swap(int* x, int* y) {
	int t = *x;
	*x = *y;
	*y = t;
}
```
