### 3.6. Operators overloading

Ранее уже была рассмотрена перегрузка отдельных операторов. Теперь рассмотрим все операторы до конца, начиная с простых арифметических операторов. **Нельзя определять собственные значки и переопределять приоритетность операций. Но можно переопределить как именно операции работают.**
 
Работать будем с таким классом:

```cpp
  struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re, double im): re(re), im(im) {}
  };
```

#### operator+

Можно наивным образом определить `operator+` следующим образом:

```cpp
  struct Complex {
    Complex operator+(const Complex& other) const { // без const не смогли бы складывать const объекты 
      return Complex(re + other.re, im + other.im);
    }
  }
```

Какая есть проблема? Представим, что есть еще конструктор от просто `double`:

```cpp
  Complex(double re): re(re) {}
```

Хотелось бы складывать не только комплексные числа друг с другом, но еще и с `double`, чтобы можно написать `Complex` + `double` и получить `Complex`; и мог написать `double` + `Complex` и получить `Complex`. Но если мы хотим так сделать, то у нас будут проблемы. Мы не сможем складывать `double` и `Complex` сейчас, мы можем складывать только `Complex` и `double` (внимание на очередность аргументов).

Проблема в том, что `operator+` это член класса. Поэтому когда мы пишем `object + value`, то это на самом деле синтаксический сахар для вот такого `object.operator+(value);`. Но мы не можем сделать это если левый аргумент это не объект класса, потому что компилятор не будет рассматривать все множество классов, в которые можно сковертировать object, чтобы вызвать соотвествующий метод при правом аргументе определенного класса. Поэтому есть давнее правило `codstyle`: если нужно определить бинарный оператор, то рекомендуется объявлять его вовне класса, то есть не надо делать их членами класса (иначе вы упускаете возможность для левого аргумента не быть членов класса). 

```cpp
  struct Complex {
    /* ... тут нет бинарных операторов ... */
  }
  
  /* а вовне класса вот есть */
  Complex operator+(const Complex& a, const Complex& b) { // тут теперь два аргумента
                                                          // потому что это не член класса
                                                          // а значит не будет неявного аргумента первого this
                                                          // и const теперь не надо, потому что это не метод класса
    return Complex(a.re + b.re, a.im + b.im);
  }
```

#### operator+=

Вот `operator+=` разумеется должен быть членом класса, потому что он берет имеющий объект класса и его модифицирует.

```cpp
  struct Complex {
    Complex& operator+=(const Complex& other) {
      *this = *this + other;
      return *this;
    }
  }
```

Но это наивная реализация. Это очень плохой код, так не надо делать, особенно для `String` или `BigInteger`. Такой код ужасно неэффективен и работает в 2 раза хуже. Вот для объектов, чье копирование нетривиально, например `string` - такой код потребует двухкратного копирования всегда, вместо того, чтобы вообще не копировать. Например, у вас строка длины 1 млн, вы хотите добавить строку длины 1. Если будет копирование, то мы будем всю эту махину реаллоцировать в памяти, хотя capacity будет хватать на то, чтобы просто дописать строку длины 1. Тогда вот тут `*this + other;` создается отдельная строка путем копирования исходных строк, потом эта строка присваивается `*this`, значит будет еще один пробег от `0` до `n`. 

Как с этим бороться? Надо `+` выражать через `+=`, потому что `+=` это быстрая операция, а `+` это медленная операция всегда. Например, если вторая строка короткая, то `+=` может работать за `O(1)`, а `+` всегда отрабает за `O(n+m)` (сумма исходных строк). 

```cpp
  struct Complex {
    Complex& operator+=(const Complex& other) {
      re += other.re;
      im += other.im;
      return *this;
    }
  }
  Complex operator+(const Complex& a, const Complex& b) {
    Complex result = a;
    result += b;
    return result;
  }
```

Вот с такой реализацией `operator+`, что будет в данном случае:

```cpp
  Complex a(1.0);
  Complex b(2.0);
  Complex c(3.0);

  a + b = c // CE or OK
```

Тут будет `ОК`. Но нам кажется странным это, потому что результатом `operator+` является `rvalue`, а значит ему нельзя присваивать... но почему мы решили, что нельзя присваивать вообще всем `rvalue`, а не только стандартным типам. В стандартне не написано, что `rvalue` не работает для левого аргумента даже для вашего кастомного типа. Вы сами это определяете, вы сами должны банить присваивание `rvalue`.

Есть два решения проблемы. Во-первых, можно возвращать тип const:

```
  const Complex operator+(const Complex& a, const Complex& b) { ... }
  // теперь тому, что вернется нельзя ничего присваивать, потому что const
```

**Но так писать не надо**. Это было актуально до `Cpp11`. Правильно сказать прямо, что `operator=` применим только к `lvalue`. Делается это посредством такой штуки как `reference-qualifier`:

```cpp
  Complex& operator=(const Complex& other) & { ... } // вот этот &
```

Вообще вот весь список `reference-qualifiers`:

```
  &  -> только к lvalue
  && -> только к rvalue
     -> к обоим (ничего не писать, это по-умолчанию)
```

Другая шальная мысль. Можно же написать вот так, буде покороче:

```cpp
  Complex operator+(Complex a, const Complex& b) {
    return a += b;
  }
```

Но так тоже не надо писать, потому что это из-за этого будет лишняя `O(n)` операция. Правильный вариант именно изначальный, в нем работает оптимизация `Return Value Optimization (RVO)`, благодаря которой при `return` не происходит копирования: суть оптимизации - если мы возвращаем локальную переменную (объявленную в теле функции, а не в параметрах), то тогда копилятор сразу создат эту локальную переменную на том месте, куда должен вернутся результат функции.

Понятное дело, что можно также определить и операторы `-`, `-=`, `*`, `*=`, `\`, `\=`, `%`, `>>`, `<<`, `|`, `~`, `&`, `^`, `||`, `,`, `>`, `<` и если что забыл - ну короче, все это можно переопределить.

#### Операторы побитового сдвига

Что тут интересного - для некоторых типов, они ведут себя не как операторы побитового сдвига, а как нечто иное. Это происходит, если у вас тип объекта это `ifstream` или `ofstream`. Когд мы хотим определить для своего типа вывод в поток, то нужно определить для типа как раз `<<` и `>>` при левом аргументе типа `поток`.

**Важное 1.** Такой оператор должен быть внешней функцией, а не членом класса. Потому что левый аргумент у него это `поток`.

**Важное 2.** Какой возвращаемый тип должен быть? `std::ofstream&` - это тип объекта `std::cout`. Почему мы вообще что-то тут возвращаем? Потому что хотим выводить в цепочку потока. Почему ссылка, а не копия? Ну потому что хотим, чтобы он не копировался всякий раз, когда мы делаем вывод чего-либо. Хотим, чтобы тот самый поток, который был - именно он к нам и вернулся.

```cpp
  std::ostream& operator<<(std::ostream& out, const String& str) {
                                  // первый аргумент тут снова поток
                                  // мы принимаем по не const ссылке, потому что хотим менять
                                  // далее наш объект по const ссылке
    for(int i = 0; i < str.sz; ++i) out << str[i]
      // там тип фундаментальный, для которого уже определен <<
      // поэтому просто посимвольно вводим в поток
  }
```

Вывод из потока похоже, но вот так

```cpp
  std::istream& operator>>(std::istream& in, String& str) {}
```

Должен ли какой-то из операторов этих быть friend? Кажется нет, потому что мы push_back все равно делать будем. Доступ к приватным полям тут не надо, но иногда надо, в `BigInt` например.

#### Оператор запятая зачем переопределять может быть

Вот есть такое понятие, как скалярное произведение векторов. Вот в некоторых библиотеках для работы с векторами и матрицами , определена как скалярное произведение. Пишете типа (vec1, vec2) в скобочках просто, и получается скалярное произведение.

#### Операторы сравнения

```cpp
  bool operator<(const Complex& a, const Complex& b) {
    return a.re < b.re || a.re == b.re && a.im < b.im;
          // И (&&) - это умножение логическое
          // ИЛИ (||) - это сложение логическое
          // отсюда и порядок выполнения
  }
```

Теперь хочу определить оператор больше, как бы вы это сделали?

```cpp
  bool operator>(const Complex& a, const Complex& b) {
    return b < a; // обратите внимание на порядок аргументов
  }
```

Нам нужно всего-лишь написать, что `b < a`, но не писать `!<=` - но это буде работать очень долго. Но `<=` у вас скорее всего реализовано отдельно `==` и `<` - получается в два раза больше действий вместо того, чтобы просто посчитать то, что уже было в `operator<` но просто поменять местами левую и правую часть.

Как теперь определить `<=` - достаточно отрицать `>`
Как теперь определить `>=` - достаточно отрицать `<`

`==` определяете как просто поэлементное сравнение

Если вы пользуетесь `map`, то его методы иногда требуют, чтобы был определен `operator<`. Поэтому если хотите класть объекты в `std::map` или `std::set` - позаботьтесь, чтобы был определен `operator<`, иначе не сможете использовать для данного класса `std::map` или `std::set`. **Именно `operator<`**, потому что stdLIB все иные операторы выражаются через `operator<`, так что вам достаточно лишь определить `operator<` и вся стандартная библиотека заработает для вас.

`operator==` может быть `default`

```cpp
  bool operator==(const Complex& other) const = default;
```

Тогда у вас будет поэлементное сравнение и `!=` доопределит сам еще.

#### spaceship <=>

Этот оператор является членом класса, вот так вот пишется

```cpp
  auto operator<=>(const Complex& other) const = default;
```

Пока не скажу какой возвращаемый тип. Фишка этого оператора в том, что про него можно написать `= default`. 

Если говорить серьезно, то этот оператор называется не космический корабль (из-за вида), а оператор `Three-way compration` - он введен в `Cpp20` для того, чтобы не надо было каждный раз долбиться с определением операторов сравнения под копирку. Почти всегда, если у вас есть оператор `<`, то все остальное определяется одинаково, какой бы вы тип не объявляли. Более того, если бы вы хотели сравнивать с друим типом без приведения, и учитывая что хотели бы, чтобы сравнивать можно было при любом порядке левой и правой части - то тогда вам уже пришлось бы определить целую кучу операторов для каждой из возможных пар.

Чтобы этого не было - ввели волшебный оператор `<=>` - теперь мы можем просто написать и тогда автоматически определяться все операторы - ЛЕКСИКОГРАФИЧЕСКИ и ничего больше не надо писать.

Работает так - если компилятор видит сравнение `a<b` вашего типа в коде, он сначала идет в него, а если его нет - то тогда мы идем в оператор `<=>` и он понимает, что значит `<` - это лексикографические меньше. При таком меньше мы не просто будем меньше писать, но оно и **работать будет быстрее**.

Так какой возвращаемый тип?

Один из трех:
std::weak_ordering
std::strong_ordering
std::partial_ordering

Добро пожаловать в математическую логику!

##### partial_ordering

Есть частичный порядок (`partial_ordering`) - для любых двух элементов может быть одно из четырех значений возвращено: меньше, больше, равен или НЕсравним. 

##### strong_ordering и weak_ordering

Сильный порядок и слабый порядок. Оба имеют три возможных значения - меньше, больше, равно. Тут НЕ бывает несравнимых. Все пары элементов сравнимы. Но чем тогда отличается строгий и слабый порядок - **разница в том что такое равнество**.

Одним из признаков предиката равенства является то, что **равенство должно сохраняться при вызове функций**. И именно этого нет в `weak_ordering` - он может вернуть вам равно если элементы не являются неразличимыми. Например, думайте тут о числах с плавающей запятой, ведь две переменные с формальным `0.0` - это немного немного разные переменные, из-за того какие особенности хранения в памяти чисел с плавающей запятой.

Если вы пишите `strong_ordering`, то `a` равно `b` - значит, что `a` неотличимо от `b` и вызов любой функции от `a` будет тем же самым, что вызов функции от `b`.

Может быть проблема из-за сравнения с разными типами. Ее мы как раз можем решить благодаря `<=>`

```cpp
  auto operator<=>(const char* other) const { // и тут уже не может быть default
    return std::weak_ordering::equivalent;
  };
```

Прелесть в том, что если мы такое написали, то он и в обратную сторону тоже будет работать. Теперь можно сравнивать и при обратном порядке левой и правовой части.

Предположим, что у нас такая реализация

```cpp
  auto operator<=>(const Complex other) const {
    return std::weak_ordering::equivalent;
  }
```

Теперь вызываем для 

```cpp
  Complex a;
  Complex b;
  a == b; // CE
```

Почему-то нет оператора `==`. Почему? Если я определяю сам `<=>`, то самостоятельно определяются все операторы, КРОМЕ `==` и `!=`. Почему так специально сделали?

Предположим, что мы сравниваем строки. Вроде понятно - просто бежим по строке. Но доопределять оператор `==` является неэффективным для строк. Для оператора `==` сначала нужно проверить `size`, а только потом бежать по строке. В лучшем случае `O(1)`, в худшем случае - `O(n+1)`. Проверка строк на равенство не надо выражать через `<`. Если определен недефолтный оператор `<=>` - то дефолтный оператор `==` не подойдет, потому что его можно будет проще определить.

#### Перезгрузка инкремента 

```cpp
  Struct UserID {
    int value = 0;
    UserID& operator++() { // это префиксный инкремент и он возвращает ссылку на текущий объект
      ++value;
      return *this;
    }
  }
```

Это **пре**фиксный инкремент. Как же сделать **пост**фиксный инкремент тогда?

```cpp
  UserID& operator()++ // МЕМ, ТАК НЕ БУДЕТ РАБОТАТЬ, НО СМЕШНО
  UserID& ++operator() // и так тоже нельзя
```

```cpp
  UserID operator++(int) { // НАДО ПРИНЯТЬ ФЕЙКОВЫЙ АРУГМЕНТ ТИПА int хахаххаа
    UserID copy = *this; 
    ++value;
    return copy;
  }
```

#### Перезгрузка круглых скобочек 

Их называют компораторами. Классический пример - это класс `Compare`, допустим

```cpp
  struct Greater {
    bool operator()(int x, int y) const {
      return x > y;
    }
  }
```

Допустим такой пример

```cpp
  std::vector<int> v(10);
  // ...
  std::sort(v.begin(), v.end(), Greater());
```

Вот в `sort` третьим параметром можно передать либо сишную функцию, которая сранивает, либо можно отдать объект класса, у которого есть оператор `()` от нужного количества аргументов нужных типов, которые возвращают bool.

Это называется **компораторы**.

Для сортировки не важно до конца, что именно вы передали. Реальную функцию или объект, у которого есть оператор круглые скобочки. В чем преимущество таких компораторов перед сишными функциями - могут быть дополнительные поля, дополнительные данные, которые будут позволять сравнивать.
