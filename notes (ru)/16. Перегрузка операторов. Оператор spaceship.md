### 3.6. Operators overloading

Ранее уже была рассмотрена перегрузка отдельных операторов. Теперь рассмотрим все операторы до конца, начиная с простых арифметических операторов. **Нельзя определять собственные значки и переопределять приоритетность операций. Но можно переопределить как именно операции работают.**

Работать будем с таким классом:

```cpp
  struct Complex {
    double re = 0.0;
    double im = 0.0;
    Complex(double re, double im): re(re), im(im) {}
  };
```

#### operator+

Можно наивным образом определить `operator+` следующим образом:

```cpp
  struct Complex {
    Complex operator+(const Complex& other) const { // без const не смогли бы складывать const объекты 
      return Complex(re + other.re, im + other.im);
    }
  }
```

Какая есть проблема? Представим, что есть еще конструктор от просто `double`:

```
  Complex(double re): re(re) {}
```

Хотелось бы складывать не только комплексные числа друг с другом, но еще и с `double`, чтобы можно написать `Complex` + `double` и получить `Complex`; и мог написать `double` + `Complex` и получить `Complex`. Но если мы хотим так сделать, то у нас будут проблемы. Мы не сможем складывать `double` и `Complex` сейчас, мы можем складывать только `Complex` и `double` (внимание на очередность аргументов).

Проблема в том, что `operator+` это член класса. Поэтому когда мы пишем `object + value`, то это на самом деле синтаксический сахар для вот такого `object.operator+(value);`. Но мы не можем сделать это если левый аргумент это не объект класса, потому что компилятор не будет рассматривать все множество классов, в которые можно сковертировать object, чтобы вызвать соотвествующий метод при правом аргументе определенного класса. Поэтому есть давнее правило `codstyle`: если нужно определить бинарный оператор, то рекомендуется объявлять его вовне класса, то есть не надо делать их членами класса (иначе вы упускаете возможность для левого аргумента не быть членов класса). 

```cpp
  struct Complex {
    /* ... тут нет бинарных операторов ... */
  }
  
  /* а вовне класса вот есть */
  Complex operator+(const Complex& a, const Complex& b) { // тут теперь два аргумента
                                                          // потому что это не член класса
                                                          // а значит не будет неявного аргумента первого this
                                                          // и const теперь не надо, потому что это не метод класса
    return Complex(a.re + b.re, a.im + b.im);
  }
```

#### operator+=

Вот `operator+=` разумеется должен быть членом класса, потому что он берет имеющий объект класса и его модифицирует.

```cpp
  struct Complex {
    Complex& operator+=(const Complex& other) {
      *this = *this + other;
      return *this;
    }
  }
```

Но это наивная реализация. Это очень плохой код, так не надо делать, особенно для `String` или `BigInteger`. Такой код ужасно неэффективен и работает в 2 раза хуже. Вот для объектов, чье копирование нетривиально, например `string` - такой код потребует двухкратного копирования всегда, вместо того, чтобы вообще не копировать. Например, у вас строка длины 1 млн, вы хотите добавить строку длины 1. Если будет копирование, то мы будем всю эту махину реаллоцировать в памяти, хотя capacity будет хватать на то, чтобы просто дописать строку длины 1. Тогда вот тут `*this + other;` создается отдельная строка путем копирования исходных строк, потом эта строка присваивается `*this`, значит будет еще один пробег от `0` до `n`. 

Как с этим бороться? Надо `+` выражать через `+=`, потому что `+=` это быстрая операция, а `+` это медленная операция всегда. Например, если вторая строка короткая, то `+=` может работать за `O(1)`, а `+` всегда отрабает за `O(n+m)` (сумма исходных строк). 

```cpp
  struct Complex {
    Complex& operator+=(const Complex& other) {
      re += other.re;
      im += other.im;
      return *this;
    }
  }
  Complex operator+(const Complex& a, const Complex& b) {
    Complex result = a;
    result += b;
    return result;
  }
```

Вот с такой реализацией `operator+`, что будет в данном случае:

```cpp
  Complex a(1.0);
  Complex b(2.0);
  Complex c(3.0);

  a + b = c // CE or OK
```

Тут будет `ОК`. Но нам кажется странным это, потому что результатом `operator+` является `rvalue`, а значит ему нельзя присваивать... но почему мы решили, что нельзя присваивать вообще всем `rvalue`, а не только стандартным типам. В стандартне не написано, что `rvalue` не работает для левого аргумента даже для вашего кастомного типа. Вы сами это определяете, вы сами должны банить присваивание `rvalue`.

Есть два решения проблемы. Во-первых, можно возвращать тип const:

```
  const Complex operator+(const Complex& a, const Complex& b) { ... }
  // теперь тому, что вернется нельзя ничего присваивать, потому что const
```

**Но так писать не надо**. Это было актуально до `Cpp11`. Правильно сказать прямо, что `operator=` применим только к `lvalue`. Делается это посредством такой штуки как `reference-qualifier`:

```cpp
  Complex& operator=(const Complex& other) & { ... } // вот этот &
```

Вообще вот весь список `reference-qualifiers`:

```
  &  -> только к lvalue
  && -> только к rvalue
     -> к обоим (ничего не писать, это по-умолчанию)
```

Другая шальная мысль. Можно же написать вот так, буде покороче:

```cpp
  Complex operator+(Complex a, const Complex& b) {
    return a += b;
  }
```

Но так тоже не надо писать, потому что это из-за этого будет лишняя `O(n)` операция. Правильный вариант именно изначальный, в нем работает оптимизация `Return Value Optimization (RVO)`, благодаря которой при `return` не происходит копирования: суть оптимизации - если мы возвращаем локальную переменную (объявленную в теле функции, а не в параметрах), то тогда копилятор сразу создат эту локальную переменную на том месте, куда должен вернутся результат функции.

Понятное дело, что можно также определить и операторы `-`, `-=`, `*`, `*=`, `\`, `\=`, `%`, `>>`, `<<`, `|`, `~`, `&`, `^`, `||`, `,`, `>`, `<` и если что забыл - ну короче, все это можно переопределить.

#### Операторы побитового сдвига

Что тут интересного - для некоторых типов, они ведут себя не как операторы побитового сдвига, а как нечто иное. Это происходит, если у вас тип объекта это `ifstream` или `ofstream`. Когд мы хотим определить для своего типа вывод в поток, то нужно определить для типа как раз `<<` и `>>` при левом аргументе типа `поток`.

**Важное 1.** Такой оператор должен быть внешней функцией, а не членом класса. Потому что левый аргумент у него это `поток`.

**Важное 2.** Какой возвращаемый тип должен быть? `std::ofstream&` - это тип объекта `std::cout`. Почему мы вообще что-то тут возвращаем? Потому что хотим выводить в цепочку потока. Почему ссылка, а не копия? Ну потому что хотим, чтобы он не копировался всякий раз, когда мы делаем вывод чего-либо. Хотим, чтобы тот самый поток, который был - именно он к нам и вернулся.

```
  std::ostream& operator<<(std::ostream& out, const String& str) {
                                  // первый аргумент тут снова поток
                                  // мы принимаем по не const ссылке, потому что хотим менять
                                  // далее наш объект по const ссылке
    for(int i = 0; i < str.sz; ++i) out << str[i]
      // там тип фундаментальный, для которого уже определен <<
      // поэтому просто посимвольно вводим в поток
  }
```

Вывод из потока похоже, но вот так

```
  std::istream& operator>>(std::istream& in, String& str) {}
```

Должен ли какой-то из операторов этих быть friend? Кажется нет, потому что мы push_back все равно делать будем. Доступ к приватным полям тут не надо, но иногда надо, в `BigInt` например.

#### Оператор запятая зачем переопределять может быть

Вот есть такое понятие, как скалярное произведение векторов. Вот в некоторых библиотеках для работы с векторами и матрицами , определена как скалярное произведение. Пишете типа (vec1, vec2) в скобочках просто, и получается скалярное произведение.

#### Операторы сравнения









