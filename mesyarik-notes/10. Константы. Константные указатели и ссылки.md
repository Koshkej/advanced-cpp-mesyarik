# 2. ?
## 2.6 Constants

`const` будет приносить нам много боли, будем решать проблемы, которые оно нам приносит, или радоваться тому что оно у нас есть. В `C` **не было констант**, поэтому работает

```cpp
char* s = "abc"; // формально в плюсах тут тип const char*
```

для обратной совместимости с `С`

#### Что же тут происходит

```cpp
const int c = 2;

int x = 5;
const int y = x;
```

`const` модификатор типа, который делает тип константным - **над этим типом запрещены модифицирующие операции**.

### Как правильно представлять себе константы, какая должна быть интуиция?

Это просто другой тип, у которого часть операций исходного типа отсутствует. Тип над которым часть операций запрещена в Compile-Time (нет присваивания, инкремента, декремента, составного присваивания). _По сути как целые и натуральные числа, потому что не все что, можно делать с целыми числами можно делать с натуральными, например, они не могут быть отрицателями или равны 0 в результате операций, то есть `N: 1-5 // CE` а `Z: 1-5 // Good`_. Так что `const int` это такой тип, который может делать все, что может `int`, но просто часть операций `int` над `const int` НЕ определены. 

Кстати: *иногда константы можно изменять, а изменять то, что не является константой - нельзя изменять*, так что лучше понимайте константы так, как выше. Все вопросы константности решаются в `C-time`. 

### Что можно делать?

**НЕЛЬЗЯ**

```cpp
const int c = 2;

c++; // CE, нет такой операции над const int
c = 2; // CE, нет такой операции над const int
c += 2 // CE, нет такой операции над const int
```

**МОЖНО**

Константу можно проинициализировать значением, переменной или какой-то константой (числом, чаром и т.п.)

```cpp
int x = 5;
const int y = x;
int z = y; // Вот так можно, причем y это lvalue (!)
```

_`y` поддерживает часть операций над `int`, а `z` и `x` - все_

### Синтаксис

Можно писать слева и справа от типа 

```cpp
const int x = 5; // вот так надо по кодстайлу Мещерина))
int const y = 5;
```

- значит одно и то же (НО СРАВНИ С ТЕМ ЧТО НИЖЕ);

### const в комбинации с указателями и ссылками

#### Const указатели

Самое веселое, когда комбинируем `const` с указателями и ссылками =)

```cpp
int a = 9;
int x = 5;
int* p = &x;

const int* pc = p; // указатель на const int => МОЖНО pc = &a НЕЛЬЗЯ *pc = 2
int* const cp = p; // const указатель на int => МОЖНО *pc = 2 НЕЛЬЗЯ pc = &a
```

**- могу поменять `pc`, но `P` изменить нельзя => разыменование `const int*` дает мне `const int`**

**- НЕ могу поменять сам `cp`, но `P` поменять можно => разыменование `int* const` дает мне `int`**

Если переставим `const int*` на другую переменную, которая не является сама по себе `const`, то изменить то, что лежит по этому указателю все равно не получится - не важно какой тип у переменной по этому указателю, важно, что тип этого указателя - `const int*`, то есть `*` от него - это `const int`, а ему нельзя присваивать

А вот если писать и слева и справа => сам указатель и то, что под ним нельзя менять

```cpp
const int* const cpc = p; // const указатель на const int => МОЖНО /**/ НЕЛЬЗЯ pc = &a *pc = 2
```

**Это именно CE, проверяется на этапе компиляции. Константность - запрет некоторых операций, поэтому корректность проверяется полностью в compile-time**.

##### Преобразование int* -> const int*

```cpp
int x = 5;
int* p = &x;

const int* pc = p // int* -> const int*
```

Произошло преобразование. Это не просто навесить `const` на тип. Подложил `const` под указатель. Это *неявное преобразование константности*, неявный `const_cast`, когда мы подкладываем `const` под `*`

В обратную сторону делать нельзя

```cpp
int* p2 = pc // int* -> const int* => CE
```

##### const указатель НЕ делает переменную на которую ссылается const

```cpp
int x = 5;
const int* p = &x;

++x;
std::cout << *p; // 6
```

Тот факт, что у меня есть указатель на `const int` еще не означает, что `int` который лежит под ним никогда не поменяется. Это дает мне гарантию, **что через этот указатель я не смогу его поменять, но не дает гарантий что кто-то другой не может его поменять используя другую переменную**.

Результату разыменования `const type*` ничего нельзя присвоить, но не отменяет факта, что результат разыменования является lvalue. 

Может быть, что на одну переменную будет и обычный указатель и указатель на константу. 

По сути как права на запись и на чтение разных пользователей на один файл.

#### Const ссылки

```cpp
int x = 5;
const int& r = x;
```

**`r` новое название для `x`, но с ограниченными правами.** То же самое что и `x`, но называя его `r` лишаемся части прав по отношению к нему. Короче, у вас есть два название одного и того же, но используя одно имя вы что-то не можете делать, а используя другое имя - можете делать все. НО если кто-то поменяет `x`, то `r` так же изменится, это очевидно. 

*Тот факт, что у меня `const int& r` еще не означает, что `r` нельзя поменять. Это означает, что ИСПОЛЬЗУЯ `r` ЕГО НЕЛЬЗЯ ПОМЕНЯТЬ*

Запрещены модифицирующие операции над `r` (см. выше)

```cpp
int const& r = x;
const int& r = x; // то же самое
```

```cpp
int& const r = x; // лишено смысла (ЧТО ТАКОЕ КОНСТАНТНАЯ ССЫЛКА
                  // - КОТОРУЮ НЕЛЬЗЯ ПЕРЕСОСЛАТЬ... НУ КАК БЫ ТАК И ЕСТЬ ПО УМОЛЧАНИЮ)
```

```cpp
int x = 5;
const int& r = x;
int& r2 = r; // CE
```

`r` дает право только на чтение и строкой с `r2` нарушаю права - пытаюсь добавить права, которых у меня не было. В обратную сторону все ок (взять доступ только на чтение к переменной, к которой был доступ и на запись и на чтение)

### НЕЛЬЗЯ СКИДЫВАТЬ const // МОЖНО НАКИДЫВАТЬ const 

```cpp
const int x = 5;
int& y = x; // CE

int z = 5;
const int& g = z; // ОК
```

### Константа должна быть проинициализирована сразу же, в момент объявления

```cpp
const int* p = new const int; // CE
const int* p = new const int(2); // OK

const int* pa = new const int[10]; // CE, не проинициализирвоал 10 констант
const int* pa = new const int[10]{}; // ОК
```

### functions

Всегда думаем, как мы хотим принимать не тривиальный аргумент в функцию (для которого копирование может быть долгим) - по ссылке, по значению, по константной ссылке

Указатели принимать не рекомендуется - C-style

1) Если просто принимаем значение, то не надо делать его константным - **бессмысленно** _(запрещаем себе менять локальную копию)_

2) Если хочу из функции менять объект, который я передал, и чтобы это влияло на исходный объект, то передаю его по ссылке

3) Если не собираюсь менять то, что принял, и просто хочу с ним работать - принимаем по константной ссылке (не делаем дорогое копирование)
 
```cpp
void f(const std::string&);

f("abcde");
```

Пытаюсь вызвать `f` от объекта, которому не соответствует никакая переменная. Происходит неявная конверсия `const char* -> const std::string&`

*Обычные ссылки инициализировать через rvalue нельзя, а константные можно* - для того, чтобы в функции всегда можно было передавать аргументы по константной ссылке (!!!).

```cpp
const int& x = 5; // OK
int& y = 10 // CE
```

**Константная ссылка может быть проинициализирована rvalue**

```cpp
{
	const std::string& s = "abc";
	/*
	создался объект типа std::string, "abc"
	скопировалось в динамическую память
	*/
	
	// ...
}
```

В какой момент уничтожится переменная `s`? Когда эта ссылка выйдет из области видимости. **Компилятор считает это имя оригинальным именем объекта и все прочие ссылки не будут влиять на уничтожение объекта.** Как только закончится время жизни `s` - уничтожится строка. Наличие иных ссылок на `s` никак влиять не будет ни на что. **Это Lifetime expansion** - продление времени жизни. Это связано с тем, что у нас нет `сборщика мусора`. Но ведет себя `s` как обычная `string&`.

`s` ведет себя как обычная `const std::string`, она не отличима от обычной строки. Где-то на стеке создалась строка и под нее сразу создалась вот эта ссылка

```cpp
{
	const std::string& s = "aaaa";
}
```

- `"aaaa"` литерал лежит в области `data`.
- на стеке создается строка, которая хранит в себе указатель на динамическую память

Получается 24 байта на стеке (size, capacity, pointer), указатель указывает в кучу, куда скопировался `"aaaa"`

Обращение к строке валидно, пока жив объект `s`.

*Переменные примитивных типов нет смысла принимать по константной ссылке - проигрываем в эффективности, так как разыменовывание указателя более долгая операция, чем просто обращение к переменной.* Надо читать память под указателем, а она может быть не загружена в кэш/регистр.

### Почему неконстантные ссылки не продлевают жизнь объектам (почему не const нельзя передать rvalue)?

_Так решил создатель сам лично_, но есть пример))

Если мы введем такое правило, то есть пример, когда все будет плохо

```cpp
void g(size_t& y) {
	++y;
}

int main() {
	int x = 0;
	g(x);
	std::cout << x;
}
```

Если бы продление жизни неконстантными ссылками было бы разрешено, то вывелось бы 0, потому что ссылка позволяет связаться с тем типом, который в точности совпадает с ее типом. В g(x) создался бы временный size_t, который увеличился бы, а потом забылся. Получается в таком случае мог бы случайно ошибившись в типе думать, что из функции поменял объект, а я на самом деле поменял его копию

Такой вызов на самом деле будет CE

```cpp
int x = 10;
const double& d = x; // Ok

double& d = x; // CE
```

`x` неявно сконвертируется в double, и именно к этому временному double и привяжется ссылка. То же самое происходило, когда инициализировал const std::string& C-style строкой

#### Перегрузка ?

```cpp
void f(const std::string&); // здесь нужна неявная конверсия - подложить const под ссылку
void f(std::string&);       // exact type matching, точное совпадение типа

void f(const std::string); /* CE будет
void f(std::string);         если без & */

int main() {
	std::string s = "abc";
	f(s);
}
```

Это корректная операция, можно определять разную обработку для константных и неконстантных объектов. **НО ТОЛЬКО ДЛЯ ССЫЛОК, для обычных типов непонятно, какую версию вызвать**

#### Висячие ссылки

```cpp
const int& g(int x) {
	return x++;
}
```

UB - создал временное значение rvalue и вернул константную ссылку на него, произошла **висячая ссылка** (данлинг референц).

**`Lifetime expansion` работает только тогда, когда мы объявляем локальную переменную с его помощью**.
С полями класс тоже не работает

#### 

```cpp
int* p = new int(0);

int** pp = &p;

const int** cpp = pp; // CE
```

**Нельзя неявно добавлять const глубже, чем на _один_ уровень под указатель.**

Почему так нельзя делать?

```cpp
int main() {
	const char x = 'a';
	char* p = nullptr;
	const char** q = &p;
	*q = &x;
	*p = 'b';
	std::cout << x;
}
```

Если сразу навесить const под два уровня, то все будет окей

```cpp
const char* const* q = &p; // OK
```
