```cpp
int a[10];
```
Объявили массив из 10 интов. Можем написать `type name[amount];`

Можно проинициализировать его элементы сразу
```cpp
int a[5] = {1, 2, 3, 4, 5};
```
Аналогично, можно сразу проинициализировать и `std::vector`

В таком случае можно даже не писать размер массива, он вычислится автоматически, в зависимости от количества переданных аргументов
```cpp
int a[] = {1, 2, 3};
```

Можно указать размер, но не перечислить все аргументы, а только часть, или вообще оставить фигурные скобочки. Тогда оставшиеся заполнятся нулями
```cpp
int a[5] = {1, 2};
int b[5] = {};
```

Если просто написать `int a[5]`, то все 5 элементов заполнятся рандомными числами

Можно не писать равно, а написать `int a[5]{1, 2};` и будет то же самое.

Можно обращаться по индексу `a[1] = 1;`. Индексация начинается с нуля. То что возвращается `a[1]` это `rvalue`.

Если выйти за границы массива, то это UB. Если выйти за границы массива слишком далеко, то это будет `segfault`, потому что массив хранится на стеке, и значит мы пытаемся далеко за границы доступного мне стека что-то записать.

Можно использовать отрицательные индексы, они иногда бывают полезны. Но делаете просто `a[-1]` - то это тоже UB, сдвигаетесь по памяти влево просто, но не на свою память.

Если завести слишком большой массив (например, 10000000), то будет `segfault`, даже без инициализации. Потому что происходит `stack overflow` - завели на стеке слишком большой массив. Потому что такой массив лежит на стеке.

**НО если написать**

```cpp
static int a[10'000'000];
```

то все будет нормально, потому что мы попросим хранить этот массив **в статической памяти**, **а не на стеке** - выделить под нее ту самую `data`. Будет выделена заранее, при старте программы.

Массивы можно использовать как **указатель на его тип**. Массив можно разыменовать - получим начальный элемент массива. Можем к массиву добавлять числа, как если бы это был указатель и тем самым получать указатель на другие его элементы.

```cpp
int a[5] = {1, 2, 3, 4, 5};
std::cout << *a; // 1
std::cout << *(a + 3); // 4
```

То есть массив неявно преобразуется в указатель на свой первый элемент. Это называется ***`Array To Pointer Conversion` - когда могу использовать массив в роли указателя***

#### Когда полезен отрицательный индекс?
`[ ]` не совсем полноценный оператор, а больше такой синтаксический сахар, штука для удобства письма

Когда мы пишем `a[2]` на самом деле, это эквивалентно `*(a + 2)`. Это буквально одно и то же, настолько, что если у меня есть указатель, то я тоже могу к нему обращаться квадратными скобочками

Массивы и указатели можно использовать взаимозаменяемо

Могу сделать так
```cpp
int a[5] = {1, 2, 3, 4, 5};

int* p = a + 3;
std::cout << p[-1]; // 3
```

Можем указатель поставить на какой-нибудь элемент массива в середине и дальше продолжать обращаться через этот указатель как будто это массив, но индексация будет идти и в отрицательную сторону

Можно написать даже `2[a]`, это то же самое, что и `a[2]` и `*(a + 2)`

Получается у нас есть три разных способа указать на один и тот же элемент

Когда я делаю `[ ]`, я делаю `*` (разыменование) от сдвинутого указателя. ***Но так работает только для массивов!*** Если есть вектор или строка, то для них это работает уже иначе.** Только для сишных массивов**.

#### Отличие массивов и указателей

Но несмотря на то, что массивы и указатели похожие вещи,. **нельзя считать, что это одно и то же.** Массивы от указателей все таки отличаются. Они отличаются тем, какие операции над ними разрешены. Можно `+` \ `-` число (НО НЕ СОСТАВНЫЕ), можно обращаться через `[]`, но:

- массивам нельзя ничего присваивать
```cpp
int b[5]{};
int a[5]{};
a = b; /* CE, если бы это работало как перестановка указателей,
	  то стек бы не смог все в правильном порядке pop
	  а если бы означало перекопируй - то неэффективно,
	  потому что работало бы за О(N) */
```
- нельзя инкрементировать массив _(я пытаюсь сдвинуть массив куда-то, но куда?)_
- нельзя делать составные присваивания

**Это все CE**

- `sizeof` будет давать разный результат. Массив вернет его суммарный размер, а указатель скорее всего 8.

ФОРМАЛЬНО ТИПЫ УКАЗАТЕЛЯ И МАССИВА ОТЛИЧАЮТСЯ

#### Указатель и массив - аргументы функции

Еще может возникнуть путаница между указателями и массивами, когда мы передаем их в функцию

```cpp
void f(int* a) {
	std::cout << "Hi!" << a[2];
}
```

В такую функцию я могу отдать массив, который неявно преобразуется в указатель

Но функция не знает что она принимает массив, она принимает именно указатель

Если у нас есть функция, которая принимает указатель на `int`, то нельзя определить еще и функцию, которая принимает массив из скольких-то там интов. Это будет считаться одной и той же функцией. ***В случае передачи в функцию, указатели и массивы снова не отличимы друг от друга***

```cpp
void f(int* a) {
	std::cout << "Hi!" << a[2];
}
void f(int a[3]) {
	std::cout << "Boom!" << a[2];
} // CE, ТАК НЕЛЬЗЯ ПЕРЕГРУЖАТЬ ФУНКЦИЮ, НАРУШЕНИЕ ODR
```

Массив в любом случае будет передан как указатель. Когда мы объявляем функцию от массива, в реальности мы объявляем функцию от указателя. Неважно какой размер у массива - при передаче в функцию это все забывается и превращается в указатель

```cpp
void f(int a[3]) {
	std::cout << "Boom!" << a[2];
} // В АРГУМЕНТЕ ИМЕННО УКАЗАТЕЛЬ
```

Поэтому даже вот так можно писать: 

```cpp
void f(int a[3]) { // здесь буквально void f(int* a) на самом деле
	std::cout << "Boom!";
}
int main() {
int x[5]{};
f(x); /* в аргументах массив от 3, а мы передаем от 5 - нормально,
	 потому что все равно передаем лишь указатель на начало массива */
}
```

***При передаче в функцию массив буквально превращается в указатель*** - `sizeof` вернет нам 8

### Массивы в динамической памяти
Можно выделить массив в динамической памяти

```cpp
int* a = new int[100]; /* результат того, что получается
			  УКАЗАТЕЛЬ, а не массив */
```
*Не путать `( )` и `[ ]`*

В этой записи все равно есть тонкость - результат того, что получается это все равно указатель, а не массив. Тип переменной `a` это настоящий, чистейшей воды указатель, ее размер будет 8. Указатель на начальный элемент.

С этим массивом мы можем спокойно работать. Можем идексировать от 0 до 99 будучи уверенным, что все это лежит подряд и это наша память. Когда закончим с ним работать, надо его освободить. Для этого пишем 

```cpp
delete[] a; // ИМЕННО ВОТ ТАК НАДО ПИСАТЬ DELETE[] POINTER
```

Важно, что здесь надо написать именно `delete[]` - в противном случае будет UB, упасть вроде не должны, но будет треш какой-то. `delete a` - то же самое, какой-то UB и потом все UB.

### В чем разница между delete и delete[] ?

Разница в том, что под капотом, функция, которая занимается выделением и освобождением памяти (находится в сишной библиотеке и обращается к ОС). 

Разница между `delete` и `delete[]` в том, что для массива, как правило надо запомнить, сколько в нем было элементов, чтобы его корректно освободить. Это делает за нас оператор `new`с квадратными скобочками

Когда пишем `new int[100]`, то на практике, скорее всего где-то перед самим массивом, запоминается, сколько в нем лежало элементов

Когда пишем `delete[]` он смотрит на то, что написано перед началом массива (сколько мы выделили) и в зависимости от этого что-то решает делать. А когда пишем `delete` просто, он решает что там один элемент, который просто надо освободить

***Это все не документировано стандартом C++ как это все происходит. Это все другого уровня абстракции***

На практике, скорее всего, перед массивом хранится число, обозначающее его размер и возможно еще какой-то сдвиг. И `delete[]` опирается на это, когда пытается освободить этот массив

Можно увидеть это число (оно скорее всего занимает 8 байт), но это гарантированная UB, в проде не повторять

```cpp
int* a = new int[2023];
int* b = new int[100000];

std::cout << *(a - 2); // 8113
std::cout << *(b - 2); /* 401410 - примерно в 4 раза больше чем то,
 				   что мы выделили (100000),
				   выше аналогично с 8113 */
```

Оно примерно соответствует тому, сколько байт я выделил под массив, но там скорее что-то еще важное хранится, но не будем вдаваться в подробности.

Интересный пример (издевательство над std::vector):

```cpp
#include <vector>
int main() {
	std::vector<int> v(10);
	v[-1] = 500000; // double free or curruption (out)
			// aborted (core dumped)
}
```

Почему ошибка? Потому что вектор под собой на самом деле тоже хранит вот этот динамический массив, вектор на самом деле это стеке два числа (размер и капейсити) и 1 указатель, а указатель указывает куда-то в динамическую память, где массив лежит; эта абстракция позволяет вам работать с динамическими массивами не думая об указателях и разхменованиях, вы работаете с ним словно это ваш удобный массив, но на деле там поинтер на динамический массив, который он подчищает за вами когда вы что-то добавляете в векторе. 

Когда я написал `v[-1]` - я отошел в динамическом массиве на 1 влево и заменил там число, потом вызвали delete посмотрел на число слева и подумал ОХРЕНИТЬ КАКОЙ У МЕНЯ РАЗМЕР, а в итоге очень странные числа и все сломалось. 

Что произойдет в этом случае?

```cpp
std::vector<int> v(10);
delete[] &v[0]; // double free (ДВА РАЗА ВЫСВОБОДИЛИ - СНАЧАЛА САМИ,
		// ПОТОМ ЕЩЕ STD::VECTOR ТО ЖЕ СДЕЛАЛ
```

### Массивы переменной длины

Это такие массивы, у которых размер не известен **на этапе компиляции**, а определяется в run-time. Динамические массивы к ним не относятся, потому что на самом деле **динамические массивы - это формально не массивы, это только формально указатели**.

```cpp
int n;
std::cin >> n;

int a[n];
```

Так делать **нежелательно, потому что стандарт C++ запрещает так делать**. Оно будет компилироваться и даже работать. Компилятор их разрешает для обратной совместимости с C (в C они были разрешены, **в C++ запрещены)**

*`VLA` - Variable Length Arrays*

Запрещены потому что использование таких массивов накладывает дополнительные расходы в `run-time` - когда у нас массив размера на стеке не известен в `compile-time`, это приводит к тому, что если мы после него будем класть что-то на стек, у нас компилятор не может превратить в правильные шаги по стеку, потому что он не знает, какие будут смещения у всех переменных, которые будут на стеке после этого массива лежать, относительно начала стека. Он их узнает только в `run-time`, а это значит, что чтобы обратиться к каждой из переменных, которые лежат правее, ему придется в `run-time` вычислять смещение относительно начала стека до этой переменной. Это дополнительное замедление. А если таких массивов несколько, то это еще хуже. В плюсах можно было, потому что там нууу например не было векторов, поэтому неудобно было.

*Если пишем на плюсах, то лучше не используем сишные массивы*

### Двумерные массивы

```cpp
int a[5][5]; // Объявил массив из 5 массивов из 5 элементов
```

```cpp
int* b[5]; // Массив из 5 указателей на `int`
```

*Чтобы правильно это читать, вспоминаем правило для операторов - то, что справа сильнее прицеплено к имени, чем то, что слева - читаем сначала вправо, потом влево*

#### Как объявить указатель на массив?

Для этого используем скобочки при определении типа

```cpp
int (*c)[5]; // Указатель на массив из 5 `int`
             // тип это другой, но численно
             // он равен указателю на нулевому элементу
	     // но формально это другой тип все
```

Представьте что есть две функции

```cpp
void f(int**) {}; // указатель на указатель
void f(int(*)[5]) {}; // указатель на массив из 5 элементов
void f(int* [5]) {};  // массив из 5 указателей int,
                      // массив разрушается до указателей,
                      // получается указатель на типа указатель int

// Какие 2 функции одного и то же, а какая иное?
// 1 и 3 - одно и то же
// потому что 3 разрушается до указателя,
// получается указатель на int* как раз int**
// нарушаем ODR
```

### C-style strings
Чтобы распознать конец строки было соглашение, что строка заканчивается тогда, когда в ней встречается символ с кодом 0

```cpp
char s[] = "abcdefghi"; // s как указатель / массив
```

Когда мы пишем такую строку, то неявно к ней добавляется символ с кодом 0. Нуль-терминатор. И на самом деле такая строка занимает не 9 байт, а 10. Хранится она в статической памяти (сам литерал, сам текст), а переменная `s` лежит на стеке, указатель на начало строки.

Когда мы работаем с сишными строками, на самом деле мы работаем с указателями на некоторые данные в статической памяти, сама строка в статической памяти лежит

Символ с кодом ноль - терминальный символ строки

Вывод строки на экран работает до терминального символа

```cpp
const char* s = "abcd\0dfgfd"; // так стало принято, потому что
			  // если пытаться поменять что-то, будет CE
			  // const const const
std::cout << s; // abcd и все
```

Я попросил вывести в поток указатель на `char`, но для указателя на `char` вывод в поток определен особым образом, не так, как для дргуих указателей, потому что указатели на `char` это обычно строки и указатели на `char` в поток выводятся таким образом - разыменовывают этот указатель и идут** до тех пор, пока не встретят первый символ с кодом 0**.

Все функции для работы со строками действуют до первого символа с кодом 0 (strcp, strlen и т.п.)

Сишные строки довольно опасны, потому что можно случайно прочитать память, которую нам не позволено читать.

### Указатели на функции

В C++, так же как и в С, можно объявлять указатели на функции

У нас есть область памяти, в которой лежит исполняемый код

Реализация функции в машинных кодах где-то записана в этой области памяти. Когда мы берем указатель на функцию, это надо понимать как то, что мы взяли указатель на начало этой области памяти, в которой машинные коды, в которой реализация памяти записана

Это может быть надо, если необходимо реализацию функции передать в функцию (например, в `std::sort` свой компаратор)

```cpp
bool cmp(int x, int y) { // компаратор
	return x > y;    // по-умолчанию сранивают через <
}

int main() {
	int a[5] = {5, 8, 3, 2, 6};
	std::sort(a, a + 5, &cmp); // БЕРЕМ АДРЕС ОТ ФУНКЦИИ
				   // 86532
}
```

Как объявить указатель на функцию?

```cpp
bool (*p)(int, int) = &cmp;
// return-type (*name)(args)
```

Указатель на функцию, которая принимает два `int` и возвращает `bool`

Можно даже не использовать амперсанд, а просто назвать имя функции и оно неявно сконвертируется - `Function To Pointer Convertion`

Если просто попросить вывести значение этого указателя 
```cpp
std::cout << p;
```
то получим 0 или 1, в зависимости от того, `nullptr` или нет.

Можем явно попросить вывести адрес
```cpp
std::cout << (void*)p;
```

**Если функция перегруженная**, то просто взять ее адрес в каком-то из expressions - это ошибка, потому что не понятно, какая из перегрузок берется

Но если мы делаем объявление указателя на функцию, в зависимости от того, какой тип слева, выражение справа даст правильный результат

```cpp
void f(int) {}
void f(double) {}

int main() {
	void (*p)(int) = &f;
	void (*p2)(double) = &f;
}
```

Получили два разных указателя - две разных функции, находящиеся по разным адресам

Перегрузка происходит не только когда я вызываю функцию, но еще когда я беру на нее адрес.

***Нельзя взять адрес у функции, которая не определена***. Если функция не определена, значит у нее нет тела, а значит в машинном коде нет места, где код этой функции записан. Поэтому если попробуем взять адрес на функцию, которая не определена, то получим ошибку линковщика, как если бы я попытался вызвать неопределенную функцию

### Default Arguments
У функций могут быть аргументы по умолчанию. Можем, объявляя какую-то функцию, сказать, что у функции есть аргументы по умолчанию. Это значит, что в функцию я их могу и не передавать, тогда подставятся значения по умолчанию. А могу их передать и тогда они заменят умолчательные значения. Могу передать один из них и тогда первый заменится, а остальные по умолчанию

```cpp
void point(int x = 3, int y = 4);
 
point(1, 2); // calls point(1, 2)
point(1);    // calls point(1, 4)
point();     // calls point(3, 4)
```

Аргументами по умолчанию могут быть только последние. Нельзя сделать первый аргумент значением по умолчанию, а второй без значения по умолчанию

```cpp
int x(int = 1, int); // Error: only the trailing parameters can have default arguments
                     // (assuming there's no previous declaration of “x”)
 
void f(int n, int k = 1);
void f(int n = 0, int k); // OK: the default argument of “k” is provided by
                          // the previous declaration in the same scope
 
void g(int, int = 7);
 
void h()
{
    void g(int = 1, int); // Error: not the same scope
}
```

### Variadic functions
**Не будем ими пользоваться никогда, просто надо знать, что они есть**

Это пришло к нам из языка C. Были функции, которым можно передавать переменное число аргументов - в параметрах написано `...`, значит функция принимает любое число аргументов, любых типов; может принимать что-то, а потом `...`, это значит, что она принимает обязательно вот это, а потом еще что-то. Такими функциями являются `printf` и `scanf`.

Вам нужно чтобы такую функцию определить использовать специальные макросы из cstdarg

![image](https://github.com/user-attachments/assets/d2f7d2ef-b4d5-49b7-b17f-0f151ab72474)

```cpp
#include <cstdarg>
#include <iostream>
 
void simple_printf(const char* fmt...) // C-style "const char* fmt, ..." is also valid
{
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0')
    {
        if (*fmt == 'd')
        {
            int i = va_arg(args, int);
            std::cout << i << '\n';
        }
        else if (*fmt == 'c')
        {
            // note automatic conversion to integral type
            int c = va_arg(args, int);
            std::cout << static_cast<char>(c) << '\n';
        }
        else if (*fmt == 'f')
        {
            double d = va_arg(args, double);
            std::cout << d << '\n';
        }
        ++fmt;
    }
 
    va_end(args);
}
 
int main()
{
    simple_printf("dcff", 3, 'a', 1.999, 42.5);
}
```

**Кодстайл не рекомендует ими пользоваться**
