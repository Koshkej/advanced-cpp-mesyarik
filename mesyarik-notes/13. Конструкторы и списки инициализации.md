## 3.3. Constructor (ctor) and Destructor (dtor)

Допустим, есть вот такой класс

```cpp
  class Complex {
    double re = 0.0;
    double im = 0.0;
  };
```

Хотелось бы создавать такой класс от набора параметров, причем необязательно даже задавать перечислением полей. Допустим, передаем какой-то параметры и на основе этого значения полей как-то инициализируются.

Что это делать - придумали `КОНСТРУКТОРЫ`.

```cpp
  class Complex {
    double re = 0.0;
    double im = 0.0;
  public:
    Complex(double real) { ... } // ВОТ ЭТО КОНСТРУКТОР
  };
```

Хотим вот так писать 

```cpp
  int main() {
    // тут везде вызывается конструтор
    Complex c1(5.0)   // Direct initialization
    Complex c2 = 6.0; // Value  initialization
    Complex c3{7.0}; 
    Complex c4 = 8.0;
  }
```

Как теперь инициализировать поля?

```cpp
  ...
    double re = 0.0;
    double im = 0.0;
  public:
    Complex(double real) {
      re = real;
  }
  ...
```

Но мы можем это улучшить, например чтобы аргумент совпадал с неймингом поля

```cpp
  ...
    double re = 0.0;
  public:
    Complex(double re) {
      this->re = re;
    }
  ...
```

**Но за такое у нас в МФТИ бьют по рукам!** Нужно не присваивать поля в конструкторе, но инициализировать их сразу перед входом в конструктор.

```cpp
  ...
    double re = 0.0; // будет игнорироваться
                     // если указываем чему присвоить
  public:
    Complex(double real) re(real) {}
    // это называется Member-initializer list
    // писать именно так принципиально
    // у вас сразу инициализация
    // а иначе бы сначала поле заводилось
    // дефолтным значением выше
    // после создавалась локальная переменная в ctor
    // и делалось присваивание
    // можно было бы даже написать c одним именем
    // Complex(double re): re(re) {} - однозначно парсится
  ...
```

Конструкторов можно создать много разных у класса

```cpp
  ...
    Complex(double re): re(re) {}
    Complex(double re, double im): re(re), im(im) {}
  ...
```

Как и иные методы, можно объявлять в классе, а определять вовне класса. Тогда там же вовне нужно определять списки инициализации.

```cpp
  ...
  // внутри класса
  public:
    Complex(double re);
  ...
  // вовне класса
    Complex::Complex(doble re): re(re) {}
```

Помним, что методы принято всегда определять вовне класса, чтобы избежать CE из-за redefinition при включении заголовочного файла. Методы объявляем в `.h` а определяем в `.cpp`.

#### Нарушение порядка инициализации полей

Допустим мы сделаем вот так

```cpp
  class Complex {
    double re = 0.0;
    double im = 0.0;
  public:
    Complex(double re, double im): im(im), re(re) {} // не по порядку
  };
```

Это не `CE`, но это `warming`. В чем проблема? 

Потенциально опасная ситуация. Если наши поля это просто числа, но если мои поля это какие-то сложные объекты, или указатели \ ссылки, причем одни ссылаются на другие, то может быть важно в каком порядке инициализируются. 

По правилам стандарта, компилятор, несмотря на то в каком реально порядке перечислен список инициализации, все равно компилятор должен обеспечить, что **поля инициализируются всегда в том порядке, в котором они объявлены в классе**. Но нарушая порядок в списке инициализации - создается путаница для тех, кто читает ваш код, потому что на самом деле инициализация будет в другому порядке (читай ранее).

#### Агрегатная инициализация

```cpp
  class Complex {
  public: // все поля публичные только если
    double re = 0.0;
    double im = 0.0;
    // нет ни одного ctor (иначе - не не работает)
  };
  
  int main() {
    Complex c{0.1, 0.2}; // Agregate initialization
                         // re -> 0.1, im -> 0.2
                         // если был бы ctor - он вызывался бы здесь 
  }
```

#### нетривиальный ctor и std::initializer_list

Вот мы пишем, допустим:

```cpp
  std::vector<int> v = {1, 2, 3, 4, 5}; 
```

Как это работает? Какой конструктор вызывается?

Нам нужен конструктор, который принимает нечто, что может хранить в себе любое количество аргументов.
Вот это и есть ctor от std::initializer_list;
НЕ **member** initializer list !!!

Но начнем с вопроса нетривиального конструтора

##### нетривиальный ctor

```cpp
  class String {
    public:
      String() {} // default ctor, ничего не делает
                  // 
                  // если поля примитивных типов не инициалированы
                  // то это UB, но у нас ниже есть инициализация
      String(size_t n, char symb): arr(new char[n + 1]), sz(n), cap(n + 1) {
        // ЭТОТ КОНСТРУКТОР НЕ ЯВЛЯЕТСЯ ТРИВИАЛЬНЫМ
        // ТРИВИАЛЬНЫЙ ЭТОТ ТОТ, КОТОРЫЙ ПРОСТО ЗАПОЛНЯЕТ ПОЛЯ
        // НО ТУТ У НАС УЖЕ ИНТЕРЕСНОЕ:
        // И ЕЩЕ НИЖЕ ЕЕ ЗАПОЛНИТЬ c СИМВОЛОМ НАДО
        //
        // как заполнить теперь?
        // можно тупо пробежаться for и типа заполнить
        // но есть оптимизированные варианты в stdlib
        //
        ...
        std::memset(arr, symb, n); // #include <cstring>
                    // == заполнить n-байт с указателя arr значением symb
                    // под arr он принимает void*
        ...
        std::fill(arr, arr + n, symb) // #include <algorithm>
        // memset и fill работают одинаково на самом деле
        // делают они умно, оптимизировано, for - не оптимизирован
        // memset и fill умеют делать кусками, с ячейками 8 байт работать
        arr[sz] = '\0'; // НУЛЬ-ТЕРМИНАТОР
      }      
    private:
      char* arr = nullptr; // указатель на место в динамической памяти
      size_t sz = 0;       // сколько элементов реально лежит
      site_t cap = 0;      // под сколько элементов выделена память
  };

  int main() {
    String s; // default initialization
  }
```

Тело конструктора правильно воспринимать как набор НЕТРИВИАЛЬНЫХ ДЕЙСТВИЙ, которые нужно совершить при создании объекта. **Если создание вашего объекта требует просто инициализации полей, то тогда никакого тела у вашего ctor быть не должно.** Не надо определять кучу конструторов на все возможные аргументы, если там вы просто поля инициализируете... вам может быть проще тогда определить какой-то один конструктор, который будет все по-умолчанию заносить... или вообще сделать поля публичными просто и будет достаточно агрегатной инициализации.

Конструкторы нужно если у вас есть какие-то нетривиальные действия при создании объекта.

##### std::initializer_list

Что он умеет? У std::initializer_list есть .begin() и .end() и .size() (как у контейнеров)

```cpp
  class String {
    public:
      // since C++11
      String(std::initializer_list<char> list)
          : arr(new char[list.size() + 1])
          , sz(list.size())
          , cap(sz + 1)
      {
        std::copy(list.begin(), list.end(), arr); // начало и конец ОТКУДА писать
                                                  // указатель куда писать
                                                  //
        arr[sz] = '\0'; // НУЛЬ-ТЕРМИНАТОР
      }
    private:
      char* arr = nullptr; // указатель на место в динамической памяти
      size_t sz = 0;       // сколько элементов реально лежит
      site_t cap = 0;      // под сколько элементов выделена память
  };

  int main() {
    String s = {'a', 'b', 'c'};
  }
```

Какие тут есть проблемы?

```cpp
  class String {
    ...
    public:
      String(size_t n, char symb) ...
      String(std::initializer_list<char> list) ...
  };

  int main() {
    String str1{5, 'a'} // ЧТО ВЫЗОВЕТСЯ? тут от initializer_list т.е. {}
    String str2(5, 'a') // тут обычный ctor, потому что () а не {}
  }
```

Вот тут вызовется ctor от `initializer_list`

Так что если мы определили ctor  от `initializer_list`
То создание объекта через **{}** - это попадаение в такой ctor

_Правило: если вы создаете объект через **{}**, то сначала рассматриваются ctor от `initializer_list`... и если ни один из них не подойдет, то тогда уже другие конструкторы будут рассматриваться._

##### Генерация ctor самим компилятором 

Если не объявили конструтор по-умолчанию, конструктор сгенерирует его сам.

```cpp
  class Complex {
    public:
      double re;
      double im;
  };

  int main() {
    Complex c; // не объявляли сами ctor дефолтный, но его сгенерировал компилятор
               // тут это означает, что все поля будут инициализированы по-умолчанию
  }
```

Если не написали - компилятор сам НЕЯВНО объявит за вас ctor по-умолчанию, который просто будут инициализировать все поля по-умолчанию или UB-мусором. 

НО если у вас есть хотя бы один явно объявленный ctor, то комплиятор не будет за вас уже генерировать ничего...

```cpp
  class Complex {
    public:
      double re;
      double im;
      Complex(double re): re(re) {};
  };

  int main() {
    Complex c; // CE т.к. есть Complex(double re): re(re) {};
  }
```

... но вы можете его попросить об этом.

```cpp
  class Complex {
    public:
      double re;
      double im;
      Complex(double re): re(re) {};
      Complex() = default; // явное объявление неявно определенного конструтора по-умолчанию
  };

  int main() {
    Complex c; // OK т.к. есть  Complex() = default
  }
```

Бывают ситуации, когда **конструктор по-умолчанию не получается сгенерировать**, даже если явно попросить сгенерировать конструктор. Когда? e.g. если есть **поля-ссылки** или поля-контанты, т.к. их нельзя оставлять без инициализации (но если мы напишем инициализацию при объявлении, то можно будет).

### Поля-ссылки

**Как в памяти хранится поле-ссылка?** Как указатель. Вот если в классе есть только поле-ссылка, то sizeof такой структуры будет как sizeof указателя (а если просто бы спросили sizeof ссылки, то получили бы размер той переменной, что лежит под данной ссылкой).

Допустим, что у меня есть такое (важный вопрос на понимание ссылок):

```cpp
  int x;
  struct S {
    int& r = ::x;
    C(int y) {
      r = y; // ::x будет теперь равен тому, чему равен y
    }
  }
```

А вот если написать так

```cpp
  int x;
  struct S {
    int& r = ::x; // игнорируется
    C(int y): r(y) {} // теперь висячая ссылка на локальную переменную
  }
```

А вот такой пример?

```cpp
  int x;
  struct S {
    const int& r = ::x;
    S(): r(5) {} // S s; что выведется при std::cout << s.r; ? UB (но мб 5 будет)
                 // помним, что константые ссылки можно инициализовать rvalue
                 // но они продлевают время жизни объектам, пока не закончится
                 // время жизни ссылки, НО ЭТО РАБОТАЕТ ТОЛЬКО ВНУТРИ ФУНКЦИИ
  }
```
