![image](https://github.com/user-attachments/assets/eb6e386f-bc09-4c43-a1de-c9a4872182e4)## 3.3. Constructor (ctor) and Destructor (dtor)

Допустим, есть вот такой класс

```cpp
class Complex {
  double re = 0.0;
  double im = 0.0;
};
```

Хотелось бы создавать такой класс от набора параметров, причем необязательно даже задавать перечислением полей. Допустим, передаем какой-то параметры и на основе этого значения полей как-то инициализируются.

Что это делать - придумали `КОНСТРУКТОРЫ`.

```cpp
class Complex {
  double re = 0.0;
  double im = 0.0;
 public:
  Complex(double real) { ... } // ВОТ ЭТО КОНСТРУКТОР
};
```

Хотим вот так писать 

```cpp
  int main() {
    // тут везде вызывается конструтор
    Complex c1(5.0)   // Direct initialization
    Complex c2 = 6.0; // Value  initialization
    Complex c3{7.0}; 
    Complex c4 = 8.0;
  }
```

Как теперь инициализировать поля?

```cpp
  ...
  double re = 0.0;
  double im = 0.0;
 public:
  Complex(double real) {
    re = real;
  }
  ...
```

Но мы можем это улучшить, например чтобы аргумент совпадал с неймингом поля

```cpp
  ...
  double re = 0.0;
 public:
  Complex(double re) {
    this->re = re;
  }
  ...
```

**Но за такое у нас в МФТИ бьют по рукам!** Нужно не присваивать поля в конструкторе, но инициализировать их сразу перед входом в конструктор.

```cpp
  ...
  double re = 0.0; // будет игнорироваться
                   // если указываем чему присвоить
 public:
  Complex(double real) re(real) {}
  // это называется Member-initializer list
  // писать именно так принципиально
  // у вас сразу инициализация
  // а иначе бы сначала поле заводилось
  // дефолтным значением выше
  // после создавалась локальная переменная в ctor
  // и делалось присваивание
  // можно было бы даже написать c одним именем
  // Complex(double re): re(re) {} - однозначно парсится
  ...
```

Конструкторов можно создать много разных у класса

```cpp
  ...
  Complex(double re): re(re) {}
  Complex(double re, double im): re(re), im(im) {}
  ...
```

Как и иные методы, можно объявлять в классе, а определять вовне класса. Тогда там же вовне нужно определять списки инициализации.

```cpp
  ...
  // внутри класса
 public:
  Complex(double re);
  ...
  // вовне класса
  Complex::Complex(doble re): re(re) {}
```

Помним, что методы принято всегда определять вовне класса, чтобы избежать CE из-за redefinition при включении заголовочного файла. Методы объявляем в `.h` а определяем в `.cpp`.

#### Нарушение порядка инициализации полей

Допустим мы сделаем вот так

```cpp
  class Complex {
      double re = 0.0;
      double im = 0.0;
     public:
      Complex(double re, double im): im(im), re(re) {} // не по порядку
  };
```

Это не `CE`, но это `warming`. В чем проблема? 

Потенциально опасная ситуация. Если наши поля это просто числа, но если мои поля это какие-то сложные объекты, или указатели \ ссылки, причем одни ссылаются на другие, то может быть важно в каком порядке инициализируются. 

По правилам стандарта, компилятор, несмотря на то в каком реально порядке перечислен список инициализации, все равно компилятор должен обеспечить, что **поля инициализируются всегда в том порядке, в котором они объявлены в классе**. Но нарушая порядок в списке инициализации - создается путаница для тех, кто читает ваш код, потому что на самом деле инициализация будет в другому порядке (читай ранее).

#### Агрегатная инициализация

```cpp
  class Complex {
   public: // все поля публичные только если
    double re = 0.0;
    double im = 0.0;
    // нет ни одного ctor (иначе - не не работает)
  };
  
  int main() {
    Complex c{0.1, 0.2}; // Agregate initialization
                         // re -> 0.1, im -> 0.2
                         // если был бы ctor - он вызывался бы здесь 
  }
```

#### std::initializer_list (НЕ member initializer list !!!)

Вот мы пишем, допустим:

```cpp
  std::vector<int> v = {1, 2, 3, 4, 5}; 
```

Как это работает? Какой конструктор вызывается?

Нам нужен конструктор, который принимает нечто, что может хранить в себе любое количество аргументов.

Вот это и есть ctor от std::initializer_list;

```cpp
  class String {
    public:
      String() {} // default ctor - ничего не делает
                  // если поля примитивных типов не инициалированы
                  // то это UB, но у нас ниже есть инициализация
    
    private:
      char* arr = nullptr; // указатель на место в динамической памяти
      size_t sz = 0;       // сколько элементов реально лежит
      site_t cap = 0;      // под сколько элементов выделена память
  };

  int main() {
    String s; // default initialization
  }
```
