## 2.7 Приведение типов

В плюсах 5 видов приведения типов, не считая неявного приведения
- C-style cast
- static cast
- dynamic cast
- reinterpret cast
- const cast

### static_cast

*Если надо привести один тип к другому, но не знаем какое нам надо из 5, то нам нужен `static_cast`*

Токен с предопределенным смыслом, нельзя переопределить. Просто ключевое слово

```cpp
int x = 5;
double y = static_cast<double>(x);
```

Все стандартные конверсии через `static_cast`

Через `static_cast` можно приводить любой указатель к указателю на `void`

*Почти всегда, когда у нас `static_cast` это означает, что неявное преобразование тоже сработало бы*

### reinterpret_cast
Способ взять биты одной переменной и трактовать их биты другой переменной ничего не перекодируя

Был long long на 8 байт. Говорим процессору читать эти 8 байт, как будто там закодирован double, ничего при этом не перекодируя

В `static_cast` происходит перекодировка, а в `reinterpret_cast` нет. *Возьми биты одного и читай их как биты другого*

При этом не обязаны соблюдать размеры - можем сделать `reinterpret_cast int->double` - возьмем 4 байта int и следующие за ними 4 байта, как если бы это был один double. Но в этих следующих 4 байтах уже может лежать что-то другое!

`reinterpret_cast` нельзя делать к новому объекту. Его можно делать либо к указателю, либо к ссылке, но не к копии

```cpp
reinterpret_cast<double>(x); // CE
reinterpret_cast<double&>(x);
```

#### Почему именно к ссылке или указателю?
Сделать каст к чему-то без ссылки или указателя - создай новый объект, а когда делаем ссылку - позволяем посмотреть на старый объект по новому. Как будто новое название старому объекту, смотрим как будто это другой тип

С помощью `reinterpret_cast` нельзя создать что-то новое. Можно только посмотреть на старое по-новому

`reinterpret_cast` позволяет прикастовать любой тип к любому. Прочитаем биты одного типа, как будто это другой тип

```cpp
long long y = 1729;
double& d = reinterpret_cast<double&>(y); // UB 
```
`y` и `d` - сущности, за которыми скрывается одна область памяти. Но обращаясь по `y` читаю как long long, а обращаясь по `d` буду читать как double

Изменив `y` изменится `d`, и наоборот

#### Почему это UB?
Нельзя читать переменную одного типа побитово, как будто это другой тип. За исключением некоторых случаев

#### Когда бывает полезен reinterpret_cast?
- если знаем, что структуры побайтово совпадают (в них одни и те же типы, в одном и том же порядке) 

Когда есть два типа, для которых преобразование из одного в другое формально не определено, но мы знаем что эти типы побитово одинаковые - в них одни и те же данные, в одном и том же формате

Если это не так, то UB

Хочу биты одного прочитать как биты другого - это `reinterpret_cast` к ссылке

Можно делать `reinterpret_cast` к указателю. С его помощью можно любой указатель прикастовать к любому другому указателю, даже если типы несовместимы

```cpp
int* p = &x;
std::string* str = reinterpret_cast<std::string*>(p);
std::cout << *str; 
```

Интерпретировал 4 байта инта, как указатель на string. Когда разыменовываю и хочу вывести - иду на эти 4 байта, отступаю от них вперед на 16 (size и capacity строки), трактую 8 байт на которые пришел как указатель в динамическую память, разыменовываю его и пытаюсь читать оттуда символы

Это Segmentation fault

### const_cast

`reinterpret_cast` запрещает обходить константность. Не позволяет сделать не const тип из const. В обратную сторону можно

`const_cast` особый каст, используется тогда, когда нам нужно отменить константность

Его так же можно делать либо к ссылке, либо к указателю


```cpp
const int c = 5;
int& cc = const_cast<int&>(c);

сс = 7; // UB
std::cout << c << ' ' << cc; 
```

Если в `const_cast` передаем вещь, которая изначально была const, то попытка изменить такую переменную это UB. Когда компилятор видит `c`, он имеет право заменить вхождения `c` на 5

Может быть ситуация, что нам дали const reference, но мы знаем, что то, что изначально то что нам дали - не было константой. Тогда имеем право сделать `const_cast` и поменять то, что там лежит

```cpp
void f(const int& c) {
	int& cc = const_cast<int&>(c);
	++cc; // изменили c
}
```

`const_cast` по кодстайлу запрещен, кроме очень редких ситуаций

`reinterpret_cast` и `const_cast` - запрещенные заклинания C++. Используем их очень редко

Можно делать `const_cast` к указателю, снимая const. Снимает const из-под указателя

Позволяет вытащить const из-под указателя или из-под ссылки

### C-style cast

Самое страшное заклинание, никогда им не пользуемся

```cpp
double d = (double) x; 
```

Почему он ужасен?
Это комбинация всех 3 кастов, описанных ранее. С помощь c-style каста можно сделать все

1) пробует сделать `const_cast`
2) пробует `static_cast`
3) пробует `static_cast` + `const_cast`
4) пробует `reinterpret_cast`
5) пробует `reinterpret_cast` + `const_cast`

Перебирает эти способы, пока хоть один не сработает. Если ни один не сработал - CE

**=> не знаем какой каст на самом деле случился**

*Использовать касты в коде - дурной тон. Они специально так страшно и длинно называются, чтобы нам хотелось как можно реже их использовать :)*

_Есть еще `dynamic_cast`, но об этом потом, когда изучим некоторые вещи еще._

## 2.8 Стадии сборки

Что происходит, когда я пишу `g++ run.cpp`?

Очень много происходит под капотом, целый конвейер операций. Файл несколько раз перерабатывается. На выходе `a.out`

**В первом приближении стадии 4**

1) препроцессинг    -> 1.cpp
2) компиляция       -> 1.asm
3) ассемблирование  -> 1.o (object file // бинарный код, не человекочитаем)
4) линковка         -> 1.out

### Препроцессинг

Обрабатываются **директивы** препроцессора 

```cpp
#include // тупо копипаст в наш код, раскрываются шаг за шагом
#if
#define 
#pragma // позволяет в коде зашить опции для компилятора
и т.п.
```

`#include <iostream>` - `<...>` после `#include` специальный сигнал препроцессору, что этот файл надо искать по стандартным путям, где лежат файлы STL. Компилятор знает заранее, где он лежит

Если поставить вместо `<...>` `"..."`, тогда будет искать не по стандартным путям, а вот там где мы сейчас находимся и в include путях, которые можем отдельно передать в качестве параметров

После этого получаем опять файл `run.cpp`, но в нем раскрыты все директивы препроцессора

После этого идет копиляция

### Компиляция
Компилятор берет код на плюсах и превращает его в код на ассемблере

На выходе получаем файл `run.s`

Очень сложная стадия, состоит из нескольких подстадий

### Ассемблирование
Код на ассемблере преобразуется в машинный. 

Получаем файл `1.o` - object file, объектный файл. Тут уже бинарный код, машинные инструкции

### Линковка

Ей занимается линкер. Из объектного файла делает исполняемый файл. Исполняемый файл уже имеет расширение `.out`

Файл `1.o` тут написаны инструкции для процессора, но на местах вызова функций, которые заинклужены стоят **заглушки**. Объявления в заголовочных файлах, а реализация в других объектниках, уже скомпилированная библиотека

**Задача линковщика в том, чтобы найти и подставить определения этих заинклуженных функций на места их вызова**. В нашем файле нет определения этих функций и в заинклуженном коде их тоже нет. Линковщик знает где они и подставляет их - в него заранее зашиты адреса файлов, где зашиты стандартные определения. Можно передавать свои объектные файлы линковщику.

Благодаря ему не компилируем библиотеки каждый раз заново. Они уже скомпилированы, мы просто компилируем свой код, в который заинклужены объявления этих функций. Задача линковщика найти и подставить определения этих функций

Исполняемый файл получается только после линковки

Подставить адреса функций тоже задача линковщика. Компилятор еще не знает, какие адреса у функций, их находит линковщик

Короче говоря, задача в том, чтобы подтянуть из уже скомпилированной библиотеке какой-то, определения в бинарном коде на места заглушек. Не нужно благодаря этому перекомпилировать `std::lib` постоянно, например. // Ошибка с использованием неопределенной функции - она как раз возникает, ликонвщик не может найти какое-либо определение нигде среди стандартных штук, ни в тех файлах, что вы ему дали. Аналогично ошибка ликонвщика - если нашлось два определения функции в разных объктных файлах.

### Step By Step Build

```shell
g++ -v run.cpp
```

`-v` - программа будет писать подробнее в лог все, что она делает

`g++` на самом деле это конвейер, он запускает одну программу за другой и обрабатываемые ими файлы

Можно попросить g++ каждую из стадий выполнить отдельно

```shell
g++ -E run.cpp
```

Сделать только препроцессинг, не делай даже компиляцию

Могу попросить g++ сделать все до ассемблирования (препроцессинг и компиляцию)

```shell
g++ -S run.cpp
```

На выходе ассемблер, а не исполняемый файл

```shell
g++ -c run.cpp
```

На выходе получаем не исполняемый, а объектный файл. Можем передать как ассемблер, так и cpp, выполнит все стадии вплоть до последней

Можно вызвать 

```shell
hd run.o
```

увидим hex dumb, то есть просто байты файла прочитать и вывести в 16-ричном формате

```shell
g++ run.o
```

получаю исполняемый файл и могу его запустить

g++ понимает что ему делать над файлом по расширению

[см. тут просто гениальный сайт godbolt](https://godbolt.org/)

## 2.9 Санитайзеры

Это специальные программы, которые по возможности позволяют **отловить UB в нашем коде**.

Опция компилятора, которая просит расставить првоерки на все потенциально опасные операции, и если что-то нарушили, то упадем в рантайме. То что питон и джава делают за нас по умолчанию

Есть несколько разных видов санитайзеров

```shell
g++ -fsanitize=address run.cpp
```

UB **НЕ** отлавливается в compile time, **мы упадем в рантайме**.

**g++ навесил кучу проверок на все обращения к памяти и теперь**, если я буду обращаться к памяти за границу, то я упаду в рантайме

Можно добавить `-g` - флаг, который добавляет дебажную информацию, **скажет нам номер строчки в исходном коде**

Когда мы так делаем, то **наш код в рантайме сильно замедляется**, РАЗ В 5-10. Поэтому не компилируем с санитайзерами всегда. Очень тяжеловесная штука. **В прод такой код отправлять не стоит** (иначе пишите на питоне))))))

Три основных санитайзера:
- address - ловит и утечки
- undefined - позволяет ловит такие штуки как переполнение int, и другие вещи
- leak - обнаружить утечки памяти
