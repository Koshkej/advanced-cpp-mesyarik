### Общие слова о языке C
Язык C++ произошел от языка C, в 80-е годы. 

В языке C были переменные, функции, указатели, работа с сырой памятью, не было ООП, наследования, классов, шаблонов, удобных стандартных контейнеров. Все приходилось писать в процедурном стиле. 

C++ добавил кучу новых возможностей, почти сохранилась обратная совместимость с C - *не любая программа, которую мы напишем на C будет корректна с точки зрения C++, но можно считать, что почти любая*

![](../images/Pasted%20image%2020240826160854.png)

Выше показано место C в C++

Возможности языка C можно изучить очень быстро

Возможности, которые предоставляет нам современный язык C++ - это просто невообразимое количество возможностей

***На самом деле современный C++ знать полностью невозможно, его никто не знает полностью.*** Современный язык C++ описывается в полуторатысячном документе - стандарте

Последняя версия C++23, полное описание всех возможностей занимает около 1700 страниц мелкого формализованного текста

Стандарт языка переиздается раз в 3 года

C++98 - первый стандарт языка C++. Потом был C++03, а следующий стандарт выходит уже в 2011 году - заканчивается эпоха олдскульного, старинного C++. После C++11 стандарты стали выходить каждые 3 года. C++11 очень сильно отличается от C++03

![](../images/Pasted%20image%2020240826162600.png)

Выше показано, сколько занимает C++03 в реальном C++

Программисты и компиляторы очень долго адаптируются к новому стандарту - пока завезут поддержку во все компиляторы, пока программисты начнут воспринимать все возможности как само собой разумеющееся. Адаптация занимает примерно 3-5 лет

***Бьерн Страуструп придумал C++, мы его будем называть Создатель.*** Он входит в комитет по стандартизации. В комитет по стандартизации входят представители из разных стран и компаний

Россию представляет Антон Полухин (Яндекс)

#### Почему именно C++?
Если изучили плюсы, то все остальное будет изучать куда легче. Время от времени появляются все новые убийцы C++ (Go, Rust и  т.д.), но плюсы пока прекрасно живут и здравствуют. Очень удобный язык, на его примере можно показать практически все концепции современного программирования. Это его достоинство и недостаток - ***универсальный язык, в котором есть практически все, что мы хотим, но из-за этого все это не до конца продумано***

Почти весь Яндекс написан на плюсах (поиск, почта, такси, лавка и т.д.), Гугл, ВК, Фэйсбук, Телеграм, ОС, Игры, Биржи, Биткоин (многие криптовалюты)

### Типы переменных. Статическая и динамическая типизация
В языке C++ есть типы переменных (данных). 
***C++ язык со статической типизацией.*** Бывают языки со статической (C++) и динамической типизацией (Python)

***Статическая типизация - все типы должны быть известны на момент компиляции. Нельзя в рантайме (в ходе выполнения программы) подменять типы переменных.*** 

Если мы объявили какую-то переменную каким-то типом (`int x;`), то эта переменная навсегда будет таким типом, нельзя никаким способом заставить ее поменять свой тип. Если кто-то говорит, что в ходе выполнения программы тип переменной изменился, то это неправда, такое никогда не может произойти, хоть нам может и показаться, что это действительно так. ***Типы у всех переменных известны на этапе компиляции***

***Статическое - на этапе компиляции; Динамическое - в рантайме***

```cpp
int x; // static typization
```

По сути наша программа - это объявление каких-то переменных, выполнение операций над ними и завершение программы.

### Integral Types (Целочисленные типы)
- `int` - 4 байта
- `long` - 4 или 8 байт (как повезет), им редко пользуются
- `long long` - 8 байт
- `short` - 2 байта
- `char` - 1 байта

Про каждый из перечисленных выше типов еще можно сказать `unsigned`. Тогда диапазон их значений сдвигается в беззнаковую сторону. 

Стандартом не регламентировано, сколько именной байт в памяти занимает `int`. Регламентировано, что он занимает хотя бы 2 байта в памяти. Скорее всего `int` будет 4 байта - 2 в 32 возможных значений [-2^31; 2^31 - 1]

***2^31 = 2.147.483.648 - это простое число***

19 января 2038 года закончится UNIX эпоха времени.

По умолчанию неизвестно какой у нас `char` знаковый или нет - это не стандартизовано. Поэтому лучше явно писать `signed` или `unsigned`

#### Типы с фиксированной шириной
Есть типы с фиксированной шириной. Во всех перечисленных выше типах не гарантируется сколько именно байт в памяти они занимают. Зачастую нам надо точно знать сколько байт занимает каждый тип (например, в структурах, которые отправляем по сети хотим знать сколько точно занимает каждое из полей). 

В этом случае нас спасают типы с фиксированной шириной
- `int8_t`
- `int16_t`
- `int32_t`
- `int64_t`

У них есть беззнаковые версии с приставкой `u` (`uint8_t`)

Есть еще тип `std::byte`. Он появился в C++17. Мотивация его ввода - `char` складывать как-то не очень красиво, давайте если хотим 1 байт, то не будем называть его `char`, а будем использовать такой тип. ***По семантике это то же самое, что  однобайтовый `int`***

#### bool
Этот тип имеют логические выражения и он требуется под `if`. 

`bool` неявно конвертируется в `int` и обратно: ***истиной считается `1`, ложь считается `0` - в одну сторону; в обратную сторону - любое ненулевое число считается истиной, `0` считается ложью***

```cpp
if (int) // true - если int это не 0, ложь в противоположном случае
```

***Неявный каст из `int`  в `bool` по стандарту разрешен***

Занимает один байт

#### size_t
Это тип, который как правило равен `unsigned long long`

Это такой беззнаковый целочисленный тип, которого достаточно, чтобы индексировать всю оперативную память (любую ячейку в массиве)

Неявно конвертируется в `int` и обратно

Это тип использующийся для индексации, потому что обычного `int` может и не хватить. `size_t` это тип для данной платформы, гарантирующий, что его хватит, чтобы все проиндексировать
### Floating Point Types (Типы с плавающей точкой)
Историческое название, исходит из того, как эти типы хранятся в памяти

- `float` - 4 байта
- `double` - 8 байт, но это не стандартизовано
- `long double` - 16 байт (вроде может и 8 байт)

#### Как хранятся числа с плавающей точкой?
У нас есть мантисса и экспонента.
Один бит под знак, сколько то бит под мантиссу и сколько то бит под экспоненту

***Экспонента - это степень 2, на которую необходимо умножить мантиссу, чтобы получить нужное число***

***Мантисса - биты, которые кодируют числовое значение***

![](../images/Pasted%20image%2020240826203936.png)

Чем больше число по модулю, тем больше там дискретность. То есть, чем больше число по модулю, тем меньше шаг, который он может закодировать

Как правило хватает `double`

***`double` точно может хранить все то, что хранит `int`.*** Если что-то влезает в `int`, то это представимо в `double` без потери точности

# Все перечисленные выше типы называются фундаментальными (fundamental types)

Некоторые типы из стандартной библиотеки являются классовыми типами (строка, вектор, мап и т.д.)

### Строки std::string и основные операции над ними
Хранит строки. Этот тип не относится к языку C, это чисто плюсовый тип, потому что `string` это класс

Позволяет хранить строки и довольно удобно с ними работать

#### Что позволяет делать std::string ?
- Можно их инициализировать. Если символы пишутся в одинарных кавычках `''`, то строки пишутся в двойных `""`
```cpp
std::string s = "abc";
```
- Можно индексировать строки квадратными скобочками `[ ]`, принимают `size_t` индекс - возвращает нам `char`, то есть символ, который находится по этому индексу. Индексация начинается с 0
```cpp
operator [](size_t)
```
Если в строке `s = "abc"` мы обратимся к `s[3]`, то ***это будет не UB, нам вернется символ с кодом 0. То есть для `std::string` гарантируется, что последним символом после тех, которые написаны лежит символ с кодом 0. Это сделано для совместимости с C, в нем строки обозначались именно так - в конце строки лежал символ с кодом 0. Это были так называемые `null-terminated strings` - все строки в C были такими, они хранились в памяти как последовательность символом, завершающаяся символом с кодом 0.***

Чтобы сохранить совместимость, чтобы можно было с этой строкой работать как с сишной строкой, стандарт C++ гарантирует, что в конце дописан символ с кодом 0

То есть обращение по индексу 3 в данном случае это еще не ошибка. А вот обращение по индексу 4 и больше это UB - может произойти все, что угодно - можем получить какой-то случайный символ или runtime error и программа упадет

Это не гарантированная ошибка, чтобы не тратить лишнее время на проверку

***Поскольку у нас C++, то один из главных принципов, которым мы будем оправдывать многие наши преступления - эффективность дороже безопасности***

***C++ это язык, который спроектирован так, чтобы быть очень быстрым в исполнении в ущерб возможным проблемам в безопасности исполняемого кода***

- Есть способ обратиться по индексу с проверкой, что мы не вышли за границы - метод `at` с такой же сигнатурой, как и у `[ ]`
```cpp
at(size_t)
```

Если нам нужно обратиться к контейнеру (строка, вектор и т.п.) с проверкой, что мы не вышли за его границы - метод `at`. Он делает абсолютно все то же самое

```cpp
s.at(1) = 'x';
```
Можем написать так, и это будет нормально работать

*Семантика абсолютно такая же, как и у квадратных скобок*

Разница лишь в том, что `at` гарантирует нам, что у нас случится ошибка (вылетит исключение `out of range`), если мы обратимся за пределы допустимого. Это работает медленнее, потому что делается дополнительная проверка

Если взять аргумент `at` равный длине строки, то есть тот индекс, где должен быть нулевой символ, то исключение тоже вылетит. То есть `at` кидает исключение, если индекс >= size

- Строки можно складывать `+` (конкатенировать). При чем можно складывать и с символами и с другими строками
- Можно делать `+=`, то есть дописывать к строке справа другую строку
- Можно делать `push_back` какой-то символ, по сути то же самое, что и сделать `+=` какой-то символ
```cpp
push_back(char)
```

- Можно делать `pop_back` - удаляем последний символ
- `front` и `back` - позволяют нам обратиться к первому и последнему символу соответственно с возможностью присваивать
```cpp
s.back() = 'y';
```
Это удобно, можно не писать `s[s.size() - 1]`, чтобы обратиться к последнему элементу. Вообще `s.size() - 1` писать опасно - может возникнуть переполнение, потому что `size()` возвращает беззнаковое число

Если строка была пустая, и мы попробуем что-нибудь присвоить через `front/back`, то будет UB

-  Метод `size` - возвращает нам размер строки, не считая нулевого символа

Строки можно сравнивать, для них определены операторы сравнения 

### std::vector и его основные операции
Вектор - это динамический массив, то есть расширяющийся по мере надобности
```cpp
std::vector<int> v;
```

Вектор умеет по сути все то же самое, что и `std::string`: квадратные скобочки, `at` по индексу

**Складывать векторы уже нельзя с другими векторами**

Одни из главных операций вектора:
- `push_back`
- `pop_back`
то есть в вектор можно докладывать элементы в конец и вынимать из конца

Аналогично с `std::string` можно делать `front` и `back`

***Вообще вектор как строка во всем, разве что складывать его нельзя с другим вектором***

Все что перечислено для строки, кроме `+` и `+=` у вектора есть и работает так же

В векторе и строке обращение по индексу (квадратные скобочки) и `at` работают за O(1) - константное время

`push_back` работает за O(1) амортизированное - если много раз делать `push_back` то в пределе  время которое мы затратили, деленое на количество раз, которое мы сделали `push_back` будет стремиться к 1. Но при этом каждый отдельно взятый `push_back` может работать долго - в худшем случае *линейное время*.

Это происходит потому что вектор расширяется по мере надобности. Изначально он выделяет сколько-то памяти, по мере того как мы делаем `push_back` эта память заполняется, а когда мы пытаемся сделать `push_back`, а память уже закончилась вектор перевыделяется (реаллоцируется) в 2 раза (то есть память увеличивается в 2 раза), а элементы которые в нем были переносятся на новое место, массив который до этого удаляется и новый элемент добавляется в конец

***У строки такое же свойство - когда мы в ней делаем `push_back`, она точно так же расширяется, по такому же правилу***

`pop_back` всегда работает за O(1), он не реаллоцирует назад, мы топим за эффективность, память не освобождаем

- Если нам нужно освободить память вектора, которую он заиспользовал, а она нам больше не нужна - метод `shrink_to_fit` (он есть и у строки)

`shrink_to_fit` заставляет дропнуть лишнюю память, чтобы ее не занимать, появился в C++11

- `clear` - очищает вектор, но он не чистит память, он только очищает сам вектор, у нас размер становится 0, но это не значит, что освободилась вся память. Тоже самое и со строкой

- `reserve` - позволяет нам предвыделить память сразу на нужное количество элементов, но не создавать сами эти элементы. *Этот метод есть и у строки*
- `resize` - это значит сделать нужный нам размер и все элементы сделать равными заданному. *Этот метод так же есть у строки*
```cpp
// string
resize(size_t, char);
resize(5, 'a'); // строка из 5 элементов, каждый из которых равен 'a'
```
Если у меня уже есть строка размером 3, и я делаю `resize(5, 'a')`, то 3 элемента останутся нетронутыми, а те которые добавятся до 5 станут равными `'a'`

`resize` - значит поменять размер вот на такой, если до этого размер был больше, то дропнуть лишнее, а если до этого размер был больше, то заполнить вторым аргументом. То же самое работает и с вектором

***Но это не имеет отношения к памяти. Если я сказал `resize(0)`, то это не значит что память освободится. Это значит, что его элементы в массиве уничтожатся, а выделенная под них память останется (память будет зарезервирована под этот вектор)***

`reserve` - предвыдели мне память вот на столько. Формально это значит - сделай так, чтобы мне вот на столько элементов мне точно хватило без реаллокаций

Но он не обязательно выделит ровно столько, сколько мы указали. Например, `reserve(10);` не сделает что именно ровно 10, *он обеспечит такое положение, что 10 элементов я смогу хранить не делая больше реаллокаций.* 
```cpp
reserve(size_t);
```

#### Частая ошибка, на которую попадаются
Если мы сделали `reserve(10)`, то это не дает нам право обращаться к 5 элементу. `reserve(10)` это значит, что мы память выделили на 10, но не значит, что мы положили реально 10 элементов туда

Например, это будет UB
```cpp
std::string s = "abc";
s.reserve(10);

// что-то начал делать с s[5] - это UB
char x = s[5] // UB
```
Потому что считается, что никакого элемента там еще не лежит, просто под него выделена память, но самого его там еще нет

- `capacity` - позволяет посмотреть, сколько зарезервировано памяти. Метод, аналогичный `size`, отвечает, под сколько элементов сейчас память зарезервирована. Есть как у строки, так и у вектора.

### Вкратце о list, deque, stack, queue, priority_queue

#### std::list
Двусвязный список

#### std::forward_list
Односвязный список, появился только в С++11

Они нужны не супер часто, по началу можно жить без них

#### std::deque
Двусторонняя очередь. Позволяет докладывать и вынимать элементы в начало и в конец, в остальном ведет себя почти как `std::vector`: умеет индексироваться за O(1) и при этом умеет докладывать элементы в начало и в конец.

***Подумать как его реализовать***

Стек и очередь формально не являются контейнерами. Они довольно неполноценные
#### std::stack
Умеет делать только `pop` и `push` и смотреть, что лежит наверху - `top`

На самом деле является так называемым ***адаптером над контейнером***, то есть `stack` это неполноценный класс сам по себе, он внутри себя хранит вектор. То есть `stack` - это некоторая надстройка, интерфейс доступа к вектору, минималистичный вектор, для красоты и ясности кода.

***По умолчанию он надстройка над деком, но можно попросить, чтобы он был надстройкой над вектором***

#### std::queue
Умеет делать `front` - смотреть, кто очередной элемент, делать `pop` - вынимать из начала и `push` - класть в конец

#### std::priority_queue
Очередь с приоритетами, то есть по сути куча. По умолчанию хранит внутри себя дек, но может и вектор. Когда мы в нее делаем `push` или `pop` она перестраивает кучу, которая хранится на массиве

### Ассоциативные контейнеры

#### std::map и его основные операции
Хранит пары ключ-значение и по ключу возвращает нам значение

*map - отображение из объектов какого-то типа `T` (key) она нам возвращает объект какого-то типа `U` (value)*

Некоторое обобщение массива, как `dict` в Python
```cpp
std::map<std::string, int> map;
//           key       value
```

Хранит все это упорядочено, элементы в нем хранятся в порядке возрастания

В `map` можно класть `std::vector`, значит его тоже можно как-то сравнивать

```cpp
operator[](key)
```
Возвращает нам соответствующее значение. Если этого значения не было, то он создает нам значение под этим ключом и инициализирует его значением по умолчанию. *Таким образом в `map` мы можем обращаться даже по несуществующему ключу и присваивать ему что-то. Просто создастся ключ с новым значением при этом*

Аналогично есть метод `at`
```cpp
at(key);
```
Если ключа не было, то ничего не сделает, а кинет нам исключение

Все работает за O(log n), потому что это упорядоченная структура данных, а именно упорядоченное дерево поиска, по стандарту не регламентировано какое, но чаще всего Красно-Черное

Есть `find`
```cpp
find(key);
```
Можем проверить, есть ли такой ключ 

Есть `insert`
```cpp
insert(pair<key, value>);
```
позволяет нам вставить пару ключа и значения 

*Пара это специальная структура, которая имеет два поля соответствующих типов*

Можно сделать `erase`
```cpp
erase(key);
```
просто убрать значение с этим ключом

Можно делать `insert/erase` по итератору

Умеет `size` - говорить, сколько в нем элементов

Не умеет хранить несколько элементов с одинаковым ключом. Если попытаемся вставить элемент с ключом, который уже существует, то он нам вернет итератор на уже существующий элемент

#### std::multimap
Во всем аналогичен обычному `std::map`, только умеет хранить несколько элементов с одинаковым ключом

В связи с этим нет `[ ]` и `at`. С такой структурой можно обращаться только по итератору.

Есть два полезных метода, которые есть у `map` и `multimap`:
- `lower_bound` - возвращает итератор на первый элемент, в котором ключ больше или равен, чем тот, который мы ему передали
- `upper_bound` - возвращает итератор на первый элемент, ключ в котором строго больше, чем мы ему дали

Таким образом можем брать диапазон он `lower_bound` до `upper_bound` и проходиться по всем элементам с одинаковым ключом

Эти методы крайне полезны в `multimap`

#### std::set
Это как `std::map`, только там хранятся не пары ключ-значение, а просто значения, и тоже хранятся упорядочено

Соответственно тоже не `[ ]` и `at`
Можно делать `find`, `insert`, `erase`

Есть `std::map`, `std::multimap`, `std::set`, `std::multiset` - позволяют хранить пары ключ-значение или просто значения в упорядоченной структуре данных, а именно в Красно-Черном дереве
#### std::unordered_map
Есть `std::unordered_map`, `std::unordered_multimap`, `std::unordered_set`, `std::unordered_multiset`

Это такая структура данных, которая хранит элементы неупорядоченно, но при этом поиск, вставка и удаление работают в среднем за O(1). Это происходит за счет того, что внутри них лежит хэш-таблица

Неупорядоченный ассоциативный массив, который хранит пары ключ-значение и почти все методы у него семантически такие же, как у `std::map`, но хранит элементы неупорядоченно 

***В среднем поиск, вставка и удаление работают за O(1). В худшем случае они могут работать за линейное время (если хэш-таблица плохо перестроена)***

***Это не амортизированное O(1), а именно в среднем***

В среднем - оно делает по входным данным, а не по номеру операции, которую мы делаем. Например, можем подобрать такую последовательность, что вставка будет происходить очень долго. Но в среднем по всевозможным последовательностям, которые мы можем вставить, то нам будет везти.

В этом разница с амортизированностью. В амортизированности мы не можем подобрать никакую последовательность входных данных, чтобы нам не везло постоянно

### Потоки std::istream и std::ostream
Когда мы пишем 
```cpp
int x = 5;
std::cout << x;
```
`std::cout` - это тоже переменная и у нее есть тип, и когда мы пишем как в примере выше, мы вызываем оператор `<<` от левого аргумента такого-то типа `std::cout` и правого аргумента типа `int`

- `std::istream` - входной поток
- `std::ostream` - выходной поток

По сути `std::cin/std:::cout` - это глобальные переменные этих типов. И у этих типов определена операция `<<` и `>>` от какого-то объекта

Таким образом, когда мы вызываем вот такую операцию, то мы у этого класса (типа) вызываем соответствующий оператор с таким-то параметром (находится справа). А там он для всех типов правильно определен и делает вывод в консоль

Есть `std::ifstream/std::ofstream` - в файл
Есть `std::istringstream/std::ostringstream` - строку трактуем как поток, делаем определенные операции, а на самом деле происходит `push_back` в строку. Иногда полезно
