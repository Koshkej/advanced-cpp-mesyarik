### Литералы и литеральные суффиксы

#### literal 
Это последовательность символов в коде программы, которая обозначает некоторое конкретное значение какого-то типа

Например,
```cpp
5; // int
0.2; // double
"abc"; // const char *
'a'; // char
```
Для каждого литерала захардкодено, к какому типу он относится 

***Литералы с плавающей точкой по умолчанию относятся к типу `double`***

#### literal suffixes
Можем попросить, чтобы литерал поменял свой тип. Например, если мы хотим, чтобы литерал с плавающей точкой считался `float`, а не `double`, мы можем написать
```cpp
0.2f;
```
Здесь `f` - это *литеральный суффикс*

Зачем нам нужно явно просить, чтобы тип литерала стал чуть другим? *Например, мы `float` и `double` обрабатываем по разному (есть функция для `float`, которая принимает `float`, и функция для `double` с таким же названием, которая принимает `double`. Если вызовем ее от `0.2`, то попадем в версию для `double`, а если от `0.2f` - попадем в версию для `float`*

Есть еще литерал `u` - означает `unsigned`
Можем явно просить `unsigned`, чтобы переполнение работало так, как мы хотим

***Если сложим два больших `int` и произойдет переполнение, то это `UB`. А если сложим два больших `unsigned` и произойдет переполнение, то это определенное поведение***

### Неявные преобразования типов
Существуют неявные преобразования типов
```cpp
int x = 5u;
```
произойдет неявное преобразование из `unsigned int` в `int`

Некоторые неявные преобразования безопасны, а некоторые опасны. Например, преобразование из `unsigned int` в `int` потенциально опасно, потому что `unsigned int` умеет хранить некоторые значения, которые обычный `int` не умеет и теоретически такое преобразование может привести к переполнению, которое приведет к `UB`

Поэтому компилятор иногда может кидать warning - тут то неявно преобразовываем

#### Какие преобразования безопасны?
- `char -> int`
- `int -> long`
- `long -> long long`

То есть преобразования, которые как бы повышают диапазон. Они еще называются ***Integer Promotions - это преобразования, которые повышают вид `int` до более высокого. Они безопасные, их можно спокойно делать. Они делаются неявно, если мы складываем два целочисленных типа разной ширины (результат будет более широкого типа)***

***Floating Point Promotions - `float` повышаем до `double`.*** Все, что представимо `float` представимо и `double`

Есть неявное преобразование между `bool` и целочисленными типами. Они тоже делаются неявно

Есть преобразования между целочисленными типами и типами с плавающей точкой. Из целочисленных типов в `double` - безопасное преобразование (попадаем в более широкое множество) и оно допустимо неявно. Если конвертируемся в обратную сторону, то мы теряем точность - отбросится дробная часть
```cpp
int x = 4.9 // x == 4
```

По хорошему компилятор кидает предупреждения в случае неявной конверсии

***Неявные конверсии - это зло***

Если мы складываем `int` и `unsigned int`, то в итоге получаем тип `unsigned`
```cpp
0 - 1u // получим 4+ миллиарда
```

***Неявные конверсии - это плохо. Избегаем их***

### Шестнадцатеричная и восьмеричная системы счисления
Целые числа можно записывать в шестнадцатеричной системе счисления. Для этого надо начать с префикса `0xff`
```cpp
0xff; // целочисленный литерал в 16-ричной системе, означает 255
```

Если мы записываем число с `0`, то это воспринимается как восьмеричная система
```cpp
0123; // это 83
```

Начиная с какого-то стандарта можно записывать в двоичной системе. Для этого используем префикс `0b`
```cpp
0b101; // 5
```

Начиная с C++14 можно, если мы записываем длинное число использовать апостроф для разделения разрядов - это удобно для чтения

### Основные команды в терминале
- `cd` - перейти в другую директорию, самая распространенная команда. Если использовать без параметров - вернуться домой, в домашнюю директорию
`..` - директория выше текущей, уровень выше
`.` - текущая директория
`~` - специальная директория, обозначает домашнюю директорию. У каждого пользователя есть своя домашняя директория

- `pwd` - узнать полный адрес директории, в которой я сейчас нахожусь
В линуксе вся файловая система растет из корневой директории `/`. Файловая система - это некоторая абстракция, которая позволяет нам представить, что все, что хранится в нашем компьютере хранится в виде дерева и оно как-то соответствует физическим дискам

Из `/` (корневой директории) растет все дерево директорий

Можно использовать клавишу `Tab`, чтобы терминал нам подсказал, что можно написать дальше - либо допишет слово, либо предложит варианты

- Есть команда `cd -` - вернись на шаг назад, где ты был до этого

- Есть команды `pushd` и `popd` - поддерживают стек директорий, где мы были и позволяют ходить по нему взад вперед

- `ls` - посмотреть, что лежит в текущей директории, просто отобразить список файлов

Параметр `-l` - отображает подробно, про каждый файл пишется какие у него права на доступ, кто владелец, группа владельца, размер, дата последнего изменения и т.д.

Применительно к директориям `x` означает, что я имею право открыть директорию

#### Почему же мне отдельным правом нужно право на выполнение, а не достаточно только права на чтение?
Дело в том, что выполнение по сути представляет из себя загрузку в оперативную память и восприятие того, что написано в этом файле, как инструкции процессора. Одно дело просто посмотреть, что там написано, а другое дело мы можем заставить процессор воспринять это как бинарный код и начать исполнять это как будто это инструкции для процессора. *Это совершенно разные вещи*

Иметь право читать какой-то файл, это еще не значит иметь право выполнить его

***Право на выполнение лучше не давать тем файлам, которые потенциально, возможно делают что-то плохое, хотя читать и смотреть на них - можно***

***Все команды терминала - это на самом деле некоторые программы и файлы этих программ лежат в директории `/bin`***

- `cat` - вывести содержимое файла на экран

В линуксе есть встроенные текстовые редакторы (например, nano). Самый трушный из них - `Vim`

Пишем `vim` а дальше название файла, который хотим создать. Если этот файл уже существовал, то он уже откроется, а если нет, то будет создан

`ctrl shift +` - увеличить масштаб
`ctrl shift -` - уменьшить масштаб

Выйти из `vim` без сохранения изменений - `:q!`
Чтобы выйти с сохранением изменений - `:wq`
Чтобы начать вводить текст надо перейти в режим вставки, по умолчанию в `vim` мы находимся в режиме команд. Перейти в режим вставки - `i`

`ctrl w` - стереть целое слово
`ctrl u` - стереть целую строку
Это же работает и в терминале

Чтобы из режима вставки вернуться обратно в нормальный режим нажимаем `Esc`

- `rm` - чтобы удалить файл
- `chmod`- позволяет менять права файла
- `chown` - поменять владельца файла
### Компиляция программ
Чтобы скомпилировать программу на C++ нам нужен компилятор. Три самых основных компилятора:
- `g++`
- `clang++`
- `msvc` - странный, у него свой взгляд на многие вещи, не согласуется со стандартом

***Не путать версию компилятора и версию языка. Еще есть версии стандартной библиотеки C++ и они тоже другие***

После успешной компиляции у нас появится файл `a.out` (по умолчанию)

Можно явно сказать как мы хотим, чтобы он назывался добавив параметр `-o`

Запускаем скомпилированный файл с помощью `./name`. Если запишем `name` без `./` то система будет искать этот исполняемый файл по умолчанию в `PATH`. `./` явно указывает, что этот файл находится в текущей директории

`main` имеет право не писать возвращаемое значение, оно дописывается по умолчанию, считается, что `main` возвращает 0

`main` возвращает 0, но кому? Вышестоящей вызывающей программе. Наша программа для нее является как бы функцией. 0 означает, что все хорошо, ничего не случилось, а если не 0 - произошла какая-то ошибка.

Из `main` почти всегда будем возвращать 0 (но не всегда)

```cpp
using namespace std;
```
Говорит нам, что все сущности, которые объявлены в пространстве имен `std` теперь как бы привнесены в нашу область видимости

***Это очень плохо, лучше так не писать***

### Declarations, definitions and scopes
Все, что мы пишем на плюсах, любая программа на плюсах - это ни что иное, как последовательность объявлений (declaration)

Когда отработал препроцессор, программа превращается в одни сплошные объявления (функции, классы, юзинги и т.п.)

На глобальном уровне, если не говорить про препроцессор, компилятор от нас ожидает, что мы что-то все время объявляем. 

Что мы можем объявлять на глобальном уровне?
- переменные
- функции
- классы
- структуры
- пространства имен
- юзинги (алиасы)
- юнионы
- и т.п.

Внутри функции мы тоже можем начать объявлять и делать некоторые другие действия. Внутри функции мы делаем уже не объявления, а так называемые стейтменты (statements). Они могут быть как объявлением, так и чем-то другим. *Но на глобальном уровне у нас все, что есть - это объявления*

***Объявление - это ввод некоторой новой сущности***
Самое простое, что мы можем объявить - переменная - тип, название, точка с запятой
```cpp
#include <iostream>

int a = 5;

int main() {

}
```
Объявили глобальный `int`. ***Глобальный означает, что находится в глобальной области видимости, не внутри ничего, на самом верхнем уровне программы***

На самом верхнем уровне программы находится так называемый *`Global Scope`*

Пока мы не открыли никакую фигурную скобку, мы находимся в глобальной области видимости

В глобальной области видимости, если мы объявляем какую-то переменную, то она инициализируется дефолтно (`int` нулем, массив занулится и т.д.). Это неверно для локальных переменных - если внутри `main` объявить `int` и не напишу то, чему он равен, то он будет содержать рандомное значение. В глобальной области видимости гарантируется, что он будет содержать 0

Можем объявлять функции
```cpp
void f(int x);
```
глобально объявил функцию `f`, у которой принимаемый тип `int`, возвращаемый тип `void`

*`void` - это такой особый тип, переменных такого типа не бывает, но он используется в функциях для возвращаемого типа, означает, что функция ничего не возвращает*

```cpp
class C;
struct S;
enum E;
union U;
```
Все это можно объявлять

Можно объявить `namespace`
```cpp
namespace N {
	int x;
}
```
Когда я объявляю `namespace`, я его должен сразу же определить. В отличие от класса, функций и др. нельзя объявить и не открыть фигурную скобку

*`namespace` - это специальное изобретение в C++, которое позволяет более удобно организовывать код, для того чтобы имена находились не в глобальной области видимости, а в какой-то вложенной.* Если большая программа, большой проект и в нем есть пересекающиеся имена (переменные, функции, классы), то удобно их разделить в неймспейсы. Просто для удобства, чтобы имена, относящиеся к разным логическим кускам нашей программы, случайно не совпали

`std` это и есть `namespace`, все сущности стандартной библиотеки объявлены именно в нем

Можем вводить свои `namespace` и заводить сущности в них

`namespace` можно переоткрыть сколько угодно раз

Можно самостоятельно что-то дописывать в `namespace std`, например, когда в `unorddered_map` хотим переопределить хэш-функцию для своих типов
