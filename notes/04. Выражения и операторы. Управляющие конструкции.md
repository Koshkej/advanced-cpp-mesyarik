### Лево- и правоассоциативные операторы
Операторы присваивания и составного присваивания правоассоциативные. Это значит, что если я напишу `x = y = z`, то это эквивалентно `x = (y = z)`

Все арифметические операторы, операторы сравнения, побитовые и логические операторы левоассоциативные. То есть, если я напишу `a + b + c`, то это эквивалентно `(a + b) + c`

Мы можем переопределять операторы для своих типов как угодно, но их ассоциативность никак не изменится

***Можно переопределить оператор `&&` для своих типов. До C++17 этот оператор терял свойство ленивых вычислений, если его перегружали. Начиная с C++17 поддерживает, даже если мы его переопределили***

### Инкремент и Декремент
- `++`
- `--`
Это унарные операторы

Бывают префиксные (`++a`) и постфиксные (`a++`)

*Инкремент - увеличение переменной на единицу*

#### Чем отличается префиксный инкремент от постфиксного?
Префиксный инкремент (`++a`) - это увеличение переменной на единицу и возвращение того, что получилось

Постфиксный инкремент (`a++`) - это увеличение переменной на единицу и возвращение того, что было

Соответственно:
- `++a` - lvalue
- `a++` - rvalue

Сам инкремент применим только к lvalue (`++(x = 5);`)

#### Можно ли написать ++a++ ?
Вопрос сводится к тому, что будет сделано раньше - префиксный или постфиксный. 

По стандарту постфиксные операции приоритетней, поэтому такая запись `++a++` эквивалентна вот такой: `++(a++)`

Если унарные операторы написаны несколько штук вокруг одного expression, то считается, что сначала делаются все постфиксные, а потом все префиксные

*Декремент - уменьшение переменной на единицу*

Для декремента все работает точно так же как и для инкремента

### Жадный лексический парсинг и понятие токенов
Лексический парсер работает по принципу - *я отщипываю как можно больше символов, до тех пор, пока эти символы еще образуют осмысленный токен (лексему)*

Поэтому выражение `a+++++b` распарсится как `((a++)++)+b`, но так нельзя, следовательно - ошибка

А вот `++++a` - это нормально, так можно

Когда компилятор парсит строку кода, он старается отщипывать как можно большие осмысленные выражения - это называется ***жадный лексический парсинг***

![](../images/Pasted%20image%2020240829113241.png)

### Тернарный оператор и его особенности
Единственный оператор, у которого 3 аргумента

Он берет свой левый аргумент, кастует его к `bool`, если истина, то он вычисляет средний аргумент и возвращает его, если ложь, то вычисляет правый аргумент и возвращает его
```cpp
left ? middle : right;
```

Здесь так же работают ленивые вычисления. Если `left` истина, то `right` не будет вычисляться; если `left` ложь, то `middle` не будет вычисляться

Будет результат lvalue или rvalue зависит от того, что было в возвращаемых выражениях

Вид value, как и тип выражения, должен быть всегда известен на этапе компиляции

Если `middle` и `right` разного вида `value` или же просто разного типа, то это CE. Компилятор должен понять какого типа выражение и какой вид value у выражения на этапе компиляции

*Если мы использовали выражение не с тем видом value, с каким можно, то это всегда CE*

### Оператор comma (запятая)
Это такой оператор, который берет левую часть, берет правую часть, вычисляет их одну за другой строго слева направо и возвращает правую часть
```cpp
a, b;
```
Гарантируется, что `b` начнет вычисляться только после того, как будет вычислена `a`

Вид `value` будет такой же как был у `b` (правой части)

На типы нет никаких ограничений. Тип выражения будет таким же, какой у правой части

Не всякая запятая в программе является оператором
```cpp
void f(int, int)
```
Здесь запятая не оператор, слева и справа стоят declaration, а не expression

***Операторы бывают только в expression***

***При вызове функции нет гарантии, что аргументы вычисляются именно слева направо***

```cpp
f(x++, x++); // вызов функции от двух аргументов, не знаем какой из них вычислится первым. На самом деле это UB

f((x++, x++)); // вызов функции с одним аргументов, гарантированно значем, что сначала вычислится левая часть, затем правая и вернется вычисленная правая
```

### Оператор sizeof
Можем спросить, сколько байт занимает переменная в памяти

Можно написать `sizeof` от переменной, можно от типа. У переменной есть тип, известный в момент компиляции, следовательно, `sizeof` от переменной всегда тоже известен в момент компиляции

Допустим у нас есть `std::vector v`. `sizeof(v)` это не то же самое, что `v.size()`

`sizeof(v)` - то, сколько байт в памяти занимает сама переменная `v`, это константа известная на момент компиляции, для всех векторов одного и того же типа одинакова
`v.size()` - количество элементов в массиве, но сам массив не является частью размера переменной, потому что он выделяется в динамической памяти

Размер вектора, как контейнера никак не влияет на размер вектора, как переменной в памяти

`sizeof` от массива - это сумма размеров его элементов

### Порядок вычислений (order of evaluation)
Если после плюса стоит пробел, то он не может распарсится как инкремент. То есть подобное выражение распарсится правильно `x++ + ++y`

`x++ * y++ + ++x` - значение выражения не определено, потому что не гарантируется, в каком порядке вычислятся аргументы

```cpp
int f() {
	std::cout << 1;
	return 1;
}

int g() {
	std::cout << 2;
	return 2;
}

int h() {
	std::cout << 3;
	return 3;
}

int main() {
	std::cout << (f() * g() + h());
}
```
Значение выражения определено однозначно, но что выведет эта программа однозначно сказать нельзя

Нет гарантии как компилятор будет это вычислять. Он мог сделать как угодно

### Правила sequenced before для порядка вычислений
Почитать на cppreference

*`side effects`* 

Рассмотрим к примеру инкремент. Вычисление инкремента это на самом деле две вещи - возврат значения и подстановка его в выражение, а также изменение значения самой переменной

Возвращение значение, то есть подстановка результата в выражение называется `value computation`

Изменение переменной называется `side effect`

До C++17 у нас не было гарантий ни относительно `value computation`, ни относительно `side effects` левого и правого операнда оператора присваивания
```cpp
int x = 0;
++x = x++;
```
До C++17 `x` мог быть равен как 0, так 1 или 2 - UB - все эти операции были недетерминированны относительно друг друга, не было требования, что `side effect` выполняется раньше, чем какой-то другой `side effect` или даже раньше, чем присваивание

Я мог сделать `value computation` и `side effect` левой части, потом сделать `value computation` правой части, затем присваивание, а уже только потом сделать `side effect` правой части - в результате получим `x == 2`

C++17 гарантирует, что и вычисление и `side effect` правой части будут сделаны до `side effect` и вычисления левой части. Гарантируется, что сначала будет сделан `side effect` и `value computation` правой части, а потом `side effect` и `value computation` правой части и только потом будет выполнен сам оператор

### Управляющие Конструкции (Control Statements)

#### Конструкция if ... else
```cpp
if (/* bool-expression */) {
	// statement
} else if (/* new condition */) {

} else {

}
```
В круглых скобках любое выражение, которое кастуется к `bool`

*Люди часто любят писать `else`, хотя `else` не нужен.* Он вообще редко нужен, если задуматься

*Последите за собой, когда пишите `if-else` и подумайте: действительно ли вам `else` нужен? Может быть мы компипастим одни и те же действия дважды*

Начиная с C++17 в `if` тоже можно делать `declaration` перед проверкой условия
```cpp
if (int x = 0; y > x) {

}
```
Это бывает полезно и иногда позволяет сделать код короче
#### Конструкция switch
```cpp
int x;
std::cin >> x;

switch (x /* expression */) {
case 1:
	std::cout << "A";
	break;
case 2:
	std::cout << "B";
	break;
default:
	std::cout << "C";
}
```
На месте `expression` должен быть какой-то целочисленный тип

`switch` работает так, что мы прыгнули на какую-то метку и выполняем все до конца `switch`, не смотря на то, что начались уже другие метки. Если хотим чтобы то, что написано под следующей меткой не выполнялось - надо написать `break`

`default` выполняется, если ни один из кейсов выше не сработал

Кажется, что `switch` довольно многословный и вместо него лучше писать `if`. Если действительно много кейсов, то писать `switch` кажется правильнее, чем `if`, потому что `switch` лучше оптимизируется компилятором

#### Цикл while и do ... while
```cpp
while (/* bool-expression */) {
	// body
}

do {
	// body
} while (/* bool-expression */);
```

#### Цикл for
```cpp
for ( declaration | expression ; bool-expression ; expression ) {

}
```
В цикле `for` у нас есть три секции в заголовки - *инициализатор, условие и итерация*

Любую из этих частей можно опустить

Можно объявлять сразу несколько переменных, но по код стайлу так делать не рекомендуется

Когда я объявляю что-то и пишу `=` - это не оператор присваивания, это специальный символ обозначающий инициализацию чего-то, но это не оператор присваивания
```cpp
int x = 0; // здесь = не оператор присваивания
```
Если мы переопределим для своих типов оператор присваивания, то он не будет здесь вызываться

Когда мы объявляем несколько вещей на одной строке это все еще не оператор `,`, это все часть синтаксиса объявления, но это не является `expression`

#### Команды break и continue
- `break` - перестань выполнять цикл, выйди из цикла и перейди к коду, который после закрывающей фигурной скобки, после тела цикла. Можно писать в `switch` и циклах
- `continue` - забей на остаток тела цикла и сразу перейди на следующую итерацию. Можно писать только в циклах

#### Команда goto и метки
Мы можем в своей программе ставить метки и делать `goto` эти метки
```cpp
int main() {
	int x = 0;

label:
	++x;
	std::cout << x << std::endl;

	goto label;
}
```
По код стайлу писать `goto` не рекомендуется, но бывают ситуации, когда оно полезно - *если у нас код в стиле C и у нас в начале функции выделяются какие-то ресурсы (открывается файл, выделяется память и т.п.) и потом в середине может произойти какая-то ошибка, а в конце функции нам надо в обратном порядке все это закрыть освободить. И в случае если случилось ошибка, мы можем сделать `goto` на строчку кода до какого момента мы успели все открыть, чтобы все освободить в обратном порядке*

Если сделать `goto` внутрь другого скоупа, то это скорее всего будет CE (если при этом пропускаются объявления других переменных)

Выходить из области видимости с помощью `goto` можно
