```cpp
int* a[10]; // массив из 10 указателей на int (сначала читается то, что справа, а потом то, что слева)

int (*b)[10]; // указатель на массив из 10 int
```

Мы берем то, что в скобках, читаем сначала то, что справа, потом то, что слева, потом выходим из скобок, опять читаем то, что справа, потом то, что слева и так далее

```cpp
void (*pf)(int); // pointer to function which takes int, return void
```

Указатель на функцию, которая принимает int и возвращает void

Но мы сталкиваемся с проблемами, когда хотим объявить указатель на функцию, которая сама возвращает указатель на функцию, или указатель на функцию, которая возвращает массив, или массив указателей на функцию

```cpp
void (*pfa[10])(int);
```

Массив из 10 указателей на функцию, принимающую int и возвращающую void

```cpp
 void (*(*pff[10])(int))(int)
```

Массив из 10 указателей на функцию, которая принимает int, а возвращает указатель на функцию, которая принимает int, а возвращает void

Это все объявления из языка C. Так называемый `cdecl`

*Если вижу справа круглые скобочки, значит это была функция*

[Сайт про C type declarations](http://unixwiz.net/techtips/reading-cdecl.html)

![image](https://github.com/user-attachments/assets/ba6d4c7e-f6c5-49ba-90d7-250175cb2dbd)

Имя переменной пишется в самых внутренних скобочках. Но мы можем не писать имя переменной, если мы хотим скастовать или передать в `sizeof`

```cpp
int (*(*)())()
```

_Указатель на функцию, которая ничего не принимает, а возвращает указатель на функцию, которая ничего не принимает, а возвращает int_

### References (ссылки)

В C у нас были указатели - адрес в памяти, по которому лежит переменная. Если мы хотим, чтобы функция меняла исходную переменную, то нам надо передавать туда не саму переменную, а указатель на нее.

Создатель подумал, что это неудобно и решил ввести новую концепцию - ***Reference (ссылка)***

У меня есть какая-то переменная `int x = 5`. Я могу захотеть создать для этой переменной другое название, чтобы переменная вроде как была другая, но на самом деле объект был тот же самый, ячейка в памяти ей соответствовала та же самая. Ну и чтобы я мог вызвать функцию от этой штуки и если я тут ее поменяю, то поменялась бы именно та самая, исходная переменная

*Для этого была придумана концепция ссылок*

Я могу написать 

```cpp
int x = 5;
int& y = x;
```

`y` - ссылка на x

Соответственно можем и в функции так же сделать - можем создать функцию, которая принимает не int, а ссылку на int. Тем самым когда мы туда отдадим x, получится что мы изменили бы его самого.

```cpp
void f(int& y) {
	++y;
}

int x = 5;
f(x); // изменим тот самый x, хоть он и называется по другому
```

`y` в функции это **тот же самый int, что был изначально**. Это не новый int, а ссылка на него, то есть это имя соответствует тому же самому int, который был изначально.

Можно проследить некую аналогию с Python/Java. В плюсах всегда, когда мы говорим что-то там равно чему-то мы всегда этим действием создаем новый объект

```cpp
std::string s = "abc";
std::string s2 = s;
```

У меня теперь существует две строки. Так работает с любым типом. **Честно** копируется, `s` и `s2` - это два **разных** объекта

Чтобы добиться поведения как в Python, чтобы сказать не создай мне новый объект, а создай мне новое имя старого объекта, я могу написать - через амперсант **&** вот так вот:

```cpp
std::string s = "abc";
std::string& s2 = s;
```

Теперь `s2` это новое имя старого объекта, а сам объект реально один

**Почему мы не можем позволить себе такую роскошь как в Python - присваивание автоматически по ссылке?** Но как нам тогда понять когда у этого объекта закончилось время жизни, когда нам его удалять из памяти, как в рантайме понять - этому объекту еще соответствует какое-то имя или нет? Для этого нужен сборщик мусора, а у нас его нет. Это роскощ (!).

Поэтому в плюсах, если мы хотим создать новое имя старому объекту, то пишем `type&`, а если мы так не напишем, то создадим новый честный объект

Как в таком случае уничтожать объект? Когда у нас выходит из области видимости вот такой тип `type&`, то с объектом ничего не происходит, а когда выходит из области видимости вот такой настоящий тип `type`, то объект уничтожается. 

***Теперь это решаемо в Compile-Time - когда должен уничтожаться объект***, а в райнтейме никакой сборщик мусора не нужен теперь.

```cpp
int x = 5;
int& y = x;
y++ // увеличится то, что под x, т.е. будет 6
int z = 7;
y = z; // то же самое что и x = z, т.е. теперь x = 7
       // но y все так же ссылка на x (не на z !)
```

**`y` и `x` - это два названия одного и того же, они неотличимы с точки зрения нас как программиста**. `y` это и есть `x`.

`вы поступили на физтех` то же самое, что и `вы поступили в МФТИ` - это взаимозаменяемые слова. Так надо мыслить о ссылках. Отныне и навсегда пока не выйдут из скоупа - `x` и `y` взаимозаменяемые, если вы поменяет `y`, то это не «**и** `x`» поменяется, а это «**именно** `x`» поменяется, потому что `x` и `y` это одно и то же.

```cpp
int& t = y; // сказал, что t ссылка на x (НЕТ ССЫЛОК НА ССЫЛКУ)

sizeof(y) // 4, потому что sizeof(int) == 4, y это все равно что x

&y == &x // true, т.к. адреса у них одинаковые
&y // тип этого выражения int* (НИКАКОЙ НЕ int&* - нету такого)
   // но формально у &y типа int& но это нужно только для того,
   // чтобы в нужное время удалять все (см. выше)
```

***Нельзя сделать ссылку на ссылку***

Когда мы в функцию принимаем что-то по ссылке, это означает, что мы в области видимости функции создали себе переменную, обозначающую ту самую переменную, которую передали, и обращение к ней внутри функции, это обращение переменной вне функции

На низком уровне это **скорее всего** реализовано через указатели, а в одной области видимости то вообще компилятор скорее всего не будет просто писать `x` вместо `y`.

Еще ссылка `y` означает, что вы в этом скоупе создали переменную, которая обозначает ту самую переменную `x`, и обращение к `y` это на самом деле обращение к `x`.

**Так что там с функциями?** 
Тут скорее всего будет как указатель. 

```cpp
void f(int& y) { // тут мы передаем &x (адрес переменной x)
		 // не будет же компилятор создавать новый int
		 // из этой функции просто нужен доступ к x
		 // ну как это можно? по его адресу в памяти
		 // но можете про это не думать, потому что
                 // компилятор дает вам перейти на новый уровень
		 // абстракции, абстрагирует вас от указателей
		 // для вас работа со ссылками должна быть
		 // такой словно работает с переменной обычной
	++y;
}

void f(int x) {
	++x;
}

int x = 5;
int& y = x;

f(x);
f(y);
```

Это **CE** со словами** ambigious call ** = _непонятно, от чего вызваться_. При чем **CE** будет не в момент, когда я эти функции объявил, **а в момент, когда я вызываюсь**. Формально это там в аргументах два разных типа, поэтому я могу объявить функцию и от такого, и от такого. Но работа с `x` и `y` должна быть неотличимой, так что вызвать `f(x)` это все равно что `f(y)` - и вот непонятно, какую функцию выбрать. Причем понятно, что ошибка будет и если вызываем f от оригинального `x` или от ссылки на него.

Ссылки позволяют нам гораздо легче реализовать функцию `swap`

```cpp
void swap(int& x, int& y) {
	int t = x;
	x = y;
	y = t;
}
```

_Кстати, помним, что это все надо различать_

```cpp
int*  // тип указателя на int переменную
int&  // тип ссылки на int переменную
&x    // адрес переменной x
*x    // разыменование указателя x
```

**Если не проинициализировать ссылку, то это CE**

```cpp
int& r; // CE
```

Ссылки нельзя оставлять без инициализации. Ссылку обязательно при **объявлении надо чем-то проинициализировать**, иначе **CE**.

**Ссылку нужно обязательно инициализировать lvalue, а не rvalue**

```cpp
int& r = 5; // CE
```

Поэтому не можем сделать `int& r = x++;`, потому что `x++` возвращает нам rvalue, а вот `int& r = ++x;` - можно, т.к. `++x` возвращает lvalue.

`++x` как раз и возвращает **ссылку** на x. Он возвращает нам новое название того же самого. Аналогично и присваивание, и разыменование указателя. 

Например, на строках. Если операция возвращает `string`, то это значит, что она создает новый `string`, а если операция возвращает `string&`, то она нам дает новое название того, что было раньше.

Еще есть const и rvalue ссылки, для них это работает иначе... потом.

**Можем возвращать ссылку из функции**

```cpp
int& g(int& x) {
	return ++x; // возвращает ссылку на то, что получилось
		    // принимает ссылку на x, так что
		    // возвращает тот же x
}
```

Теперь я могу написать 

```cpp
g(x) = 6; // g(x) - это lvalue, как бы другое название того, что получилось
          // после `работы` над x 
```

Потому что `g(x)` это теперь lvalue - оно возвращает ссылку, ее результат это какая-то переменная, которой можно присваивать. 

Более естественная запись этого вот:

```cpp
v[x] = 6;
```

**Теперь мы понимаем что такое `[]` на самом деле, они просто должны вам ссылку возвращать и тогда указателю можно присваивать что-то.** За счет чего мы можем присваивать что-либо результату квадратных скобочек? За счет того, что их возвращаемый объект - это ссылка. Они не создают нам новый объект, они дают нам другой способ именовать то, что уже где-то под ними лежит.

По сути когда мы пользуемся квадратными скобочками в векторе, **мы делаем разыменование некоторого указателя** - в векторе хранится массив и мы **делаем разыменование** какой-то ячейки этого массива, **получаем саму ячейку** и **возвращаем ее по ссылке**. Тем самым результату квадратных скобочек мы можем присваивать, и это присваивание будет означать модификацию той самой ячейки.

Можем сделать вот так

```cpp
int& t = g(x); // говорим `пускай теперь g(x) называется t
```

Различаем вот с этим

```cpp
int t = g(x);  // скопируй значение g(x) в t (новая переменная)
```

Тут происходит **Lvalue to Rvalue conversion**. 

### lvalue to rvalue conversion

```cpp
int t = g(x);
```

`g(x)` или `p*` можно понять в двух смыслах, это можно понять как ячейку памяти, в которой лежит там int какой-то (_ТА САМАЯ ЯЧЕЙКА, И ВОТ ПРИСВОЙ ЕЙ_) - тогда это `lvalue`, а можно воспринимать как значение, которое лежит в той ячейки и тогда это `rvalue` (_ЗНАЧЕНИЕ КОТОРОЕ ЛЕЖИТ В ЯЧЕЙКЕ ПРОЧИТАЙ_).

```cpp
*p = *pp  // *p - ПОЛОЖИ в ячейку                        lvalue
	  // **p - ВОЗЬМИ (ПРОЧИТАЙ) ЗНАЧЕНИЕ из ячейки  rvalue
```

Есть еще `int&&`... это не ссылка на ссылку... а что это? узнаем потом

### Dangling reference (висячая / битая ссылка)

```cpp
int& f(int& x) {
	int y = ++x; // создали локальную переменную
	return y;    // вернули ссылку на нее
}

int x = 0;
int& y = f(x); // создали еще одну ссылку... на y выше, который закончился
```

Аналогично в этом случае:

```cpp
int& f(int x) {
	int& y = ++x; // создали локальную переменную
	return y;     // вернули ссылку на нее
}
```

**Это UB, один из классических и часто встречающихся примеров**

Создал переменную, время жизни которой заканчивается, когда заканчивает работать функция, а ссылку на переменную вернул наружу. Получается, когда я вышел из этой функции у меня есть другое имя для переменной,** а самой переменной уже нет, а имя все еще валидно**.

Почему не **CE**? На каких-то новых версия clang это стало CE... и кажется, что в C++23 или уже даже в C++20 это стало CE все же так делать. Ну вроде это все может сделать компилятор в compile-time, это решается статически, так что вполне вероятно что НАДО кидать CE конечно.

Если приняли что-то в функцию по значению, а потом вернули из этой функции по ссылке, то это тоже dangling reference, потому что это та переменная локальная для этой функции.

**Но вот так будет окей:**

```cpp
int& f() {
	static int y = 0;
	return y;
}
```

Это корректная запись, потому что `y` существует все время работы программы, она не уничтожается, когда мы выходим из `f`, а значит возвращать ссылку на нее и обращаться к ней по этой ссылке тоже корректно. Аналогично если бы `y` была глобальная переменная / поле класса.

```cpp
int& g() {
	int* p = new int(1);
	return *p;
}

int& x = g();
delete &x;
```

Это тоже **корректная** запись, никаких ошибок не будет.

Если написать `int x = g();`, то это уже будет ошибка, попробую удалить копию `x`, он будет на стеке, поэтому получу скорее всего segmentation fault

### Ссылка на указатель
```cpp
int x = 0;
int* p = &x;
int*& p2 = p;
```
Корректная запись, p2 теперь тот же самый указатель, что и p. Буквально

Если потом сделать
```cpp
p = new int(5);
delete p2;
```
то все будет корректно работать

***`int&*` делать нельзя, это сразу CE***
Указателя на ссылку не бывает, как и ссылок на ссылку

### Ссылка на массив
```cpp
int a[10];
int (&b)[10] = a;
```
`b` это ссылка на массив `a`. Теперь `b` это то же самый массив, что и `a`

Читается аналогично, смотри cdecl

Можно передать массив в функцию по ссылке

***Массив из ссылок создать нельзя***
`int& c[10]` нельзя, `std::vector` тоже нельзя

### Ссылка на функцию
Можно создать ссылку на функцию

```cpp
void f(int);

void (&g)(int) = f;
```
Создали ссылку на функцию `f`

Не знаем, где это может пригодиться
